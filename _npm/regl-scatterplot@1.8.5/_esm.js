/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/regl-scatterplot@1.8.5/dist/regl-scatterplot.esm.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import e from"../pub-sub-es@2.0.2/_esm.js";import t from"../regl@2.1.0/_esm.js";var n,o="undefined"!=typeof Float32Array?Float32Array:Array;function r(){var e=new o(16);return o!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function i(e){var t=new o(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function a(e,t){var n=t[0],o=t[1],r=t[2],i=t[3],a=t[4],s=t[5],l=t[6],c=t[7],d=t[8],u=t[9],p=t[10],m=t[11],h=t[12],f=t[13],y=t[14],g=t[15],v=n*s-o*a,w=n*l-r*a,x=n*c-i*a,b=o*l-r*s,S=o*c-i*s,E=r*c-i*l,P=d*f-u*h,C=d*y-p*h,M=d*g-m*h,A=u*y-p*f,I=u*g-m*f,R=p*g-m*y,T=v*R-w*I+x*A+b*M-S*C+E*P;return T?(T=1/T,e[0]=(s*R-l*I+c*A)*T,e[1]=(r*I-o*R-i*A)*T,e[2]=(f*E-y*S+g*b)*T,e[3]=(p*S-u*E-m*b)*T,e[4]=(l*M-a*R-c*C)*T,e[5]=(n*R-r*M+i*C)*T,e[6]=(y*x-h*E-g*w)*T,e[7]=(d*E-p*x+m*w)*T,e[8]=(a*I-s*M+c*P)*T,e[9]=(o*M-n*I-i*P)*T,e[10]=(h*S-f*x+g*v)*T,e[11]=(u*x-d*S-m*v)*T,e[12]=(s*C-a*A-l*P)*T,e[13]=(n*A-o*C+r*P)*T,e[14]=(f*w-h*b-y*v)*T,e[15]=(d*b-u*w+p*v)*T,e):null}function s(e,t,n){var o=t[0],r=t[1],i=t[2],a=t[3],s=t[4],l=t[5],c=t[6],d=t[7],u=t[8],p=t[9],m=t[10],h=t[11],f=t[12],y=t[13],g=t[14],v=t[15],w=n[0],x=n[1],b=n[2],S=n[3];return e[0]=w*o+x*s+b*u+S*f,e[1]=w*r+x*l+b*p+S*y,e[2]=w*i+x*c+b*m+S*g,e[3]=w*a+x*d+b*h+S*v,w=n[4],x=n[5],b=n[6],S=n[7],e[4]=w*o+x*s+b*u+S*f,e[5]=w*r+x*l+b*p+S*y,e[6]=w*i+x*c+b*m+S*g,e[7]=w*a+x*d+b*h+S*v,w=n[8],x=n[9],b=n[10],S=n[11],e[8]=w*o+x*s+b*u+S*f,e[9]=w*r+x*l+b*p+S*y,e[10]=w*i+x*c+b*m+S*g,e[11]=w*a+x*d+b*h+S*v,w=n[12],x=n[13],b=n[14],S=n[15],e[12]=w*o+x*s+b*u+S*f,e[13]=w*r+x*l+b*p+S*y,e[14]=w*i+x*c+b*m+S*g,e[15]=w*a+x*d+b*h+S*v,e}function l(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function c(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function d(e,t,n){var o=t[0],r=t[1],i=t[2],a=t[3];return e[0]=n[0]*o+n[4]*r+n[8]*i+n[12]*a,e[1]=n[1]*o+n[5]*r+n[9]*i+n[13]*a,e[2]=n[2]*o+n[6]*r+n[10]*i+n[14]*a,e[3]=n[3]*o+n[7]*r+n[11]*i+n[15]*a,e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)}),n=new o(4),o!=Float32Array&&(n[0]=0,n[1]=0,n[2]=0,n[3]=0),function(){var e=function(){var e=new o(2);return o!=Float32Array&&(e[0]=0,e[1]=0),e}()}();const u=(e=[0,0],t=1,n=0,o=[0,0],i=[[0,1/0],[0,1/0]],u=[[-1/0,1/0],[-1/0,1/0]])=>{const p=new Float32Array(16),m=new Float32Array(16),h=new Float32Array(16);let f=r(),y=[...o.slice(0,2),0,1];const g=Array.isArray(i[0])?[...i[0]]:[...i],v=Array.isArray(i[0])?[...i[1]]:[...i],w=Array.isArray(u[0])?[...u[0]]:[...u],x=Array.isArray(u[0])?[...u[1]]:[...u],b=()=>function(e,t){var n=t[0],o=t[1],r=t[2],i=t[4],a=t[5],s=t[6],l=t[8],c=t[9],d=t[10];return e[0]=Math.hypot(n,o,r),e[1]=Math.hypot(i,a,s),e[2]=Math.hypot(l,c,d),e}(p,f).slice(0,2),S=()=>{const e=b();return Math.min(e[0],e[1])},E=()=>{const e=b();return Math.max(e[0],e[1])},P=([e=0,t=0]=[],n=1,o=0)=>{f=r(),C([-e,-t]),A(o),M(1/n)},C=([e=0,t=0]=[])=>{p[0]=e,p[1]=t,p[2]=0;const n=l(m,p);s(f,n,f)},M=(e,t)=>{const n=Array.isArray(e);let o=n?e[0]:e,r=n?e[1]:e;if(o<=0||r<=0||1===o&&1===r)return;const i=b(),d=i[0]*o,u=i[1]*r;if(o=Math.max(g[0],Math.min(d,g[1]))/i[0],r=Math.max(v[0],Math.min(u,v[1]))/i[1],1===o&&1===r)return;p[0]=o,p[1]=r,p[2]=1;const w=c(m,p),x=t?[...t,0]:y,S=l(p,x);s(f,S,s(f,w,s(f,a(h,S),f)))},A=e=>{const t=r();!function(e,t,n){var o,r,i,a=n[0],s=n[1],l=n[2],c=Math.hypot(a,s,l);c<1e-6||(a*=c=1/c,s*=c,l*=c,o=Math.sin(t),i=1-(r=Math.cos(t)),e[0]=a*a*i+r,e[1]=s*a*i+l*o,e[2]=l*a*i-s*o,e[3]=0,e[4]=a*s*i-l*o,e[5]=s*s*i+r,e[6]=l*s*i+a*o,e[7]=0,e[8]=a*l*i+s*o,e[9]=s*l*i-a*o,e[10]=l*l*i+r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1)}(t,e,[0,0,1]),s(f,t,f)},I=e=>{!e||e.length<16||(f=e)};return P(e,t,n),{get translation(){return function(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}(p,f).slice(0,2)},get target(){return d(p,y,a(h,f)).slice(0,2)},get scaling(){return b()},get minScaling(){return S()},get maxScaling(){return E()},get scaleBounds(){return[[...g],[...v]]},get translationBounds(){return[[...w],[...x]]},get distance(){return(()=>{const e=b();return[1/e[0],1/e[1]]})()},get minDistance(){return 1/S()},get maxDistance(){return 1/E()},get rotation(){return Math.acos(f[0]/E())},get view(){return f},get viewCenter(){return y.slice(0,2)},lookAt:P,translate:C,pan:C,rotate:A,scale:M,zoom:M,reset:()=>{P(e,t,n)},set:(...e)=>(console.warn("`set()` is deprecated. Please use `setView()` instead."),I(...e)),setScaleBounds:e=>{const t=Array.isArray(e[0]);g[0]=t?e[0][0]:e[0],g[1]=t?e[0][1]:e[1],v[0]=t?e[1][0]:e[0],v[1]=t?e[1][1]:e[1]},setTranslationBounds:e=>{const t=Array.isArray(e[0]);w[0]=t?e[0][0]:e[0],w[1]=t?e[0][1]:e[1],x[0]=t?e[1][0]:e[0],x[1]=t?e[1][1]:e[1]},setView:I,setViewCenter:e=>{y=[...e.slice(0,2),0,1]}}},p=["pan","rotate"],m={alt:"altKey",cmd:"metaKey",ctrl:"ctrlKey",meta:"metaKey",shift:"shiftKey"},h=(e,{distance:t=1,target:n=[0,0],rotation:o=0,isNdc:r=!0,isFixed:i=!1,isPan:a=!0,isPanInverted:s=[!1,!0],panSpeed:l=1,isRotate:c=!0,rotateSpeed:d=1,defaultMouseDownMoveAction:h="pan",mouseDownMoveModKey:f="alt",isZoom:y=!0,zoomSpeed:g=1,viewCenter:v,scaleBounds:w,translationBounds:x,onKeyDown:b=(()=>{}),onKeyUp:S=(()=>{}),onMouseDown:E=(()=>{}),onMouseUp:P=(()=>{}),onMouseMove:C=(()=>{}),onWheel:M=(()=>{})}={})=>{let A=u(n,t,o,v,w,x),I=0,R=0,T=0,O=0,L=0,B=0,$=!1,z=0,D=1,k=1,F=1,N=!1,j=!1,_=!1,V="pan"===h,W=a,Z=a,q=s,G=s,H=y,K=y;const X=()=>{W=Array.isArray(a)?Boolean(a[0]):a,Z=Array.isArray(a)?Boolean(a[1]):a,q=Array.isArray(s)?Boolean(s[0]):s,G=Array.isArray(s)?Boolean(s[1]):s,H=Array.isArray(y)?Boolean(y[0]):y,K=Array.isArray(y)?Boolean(y[1]):y};X();const Y=r?e=>e/D*2*F:e=>e,U=r?e=>e/k*2:e=>-e,J=r?e=>(e/D*2-1)*F:e=>e,Q=r?e=>1-e/k*2:e=>e,ee=()=>{const t=e.getBoundingClientRect();D=t.width,k=t.height,F=D/k},te=e=>{_=!1,S(e)},ne=e=>{_=e[m[f]],b(e)},oe=e=>{$=!1,P(e)},re=e=>{$=1===e.buttons,E(e)},ie=void 0!==document.createEvent("MouseEvent").offsetX?e=>{T=e.offsetX,O=e.offsetY}:t=>{const n=e.getBoundingClientRect();T=t.clientX-n.left,O=t.clientY-n.top},ae=e=>{I=e.clientX,R=e.clientY},se=e=>{ae(e),C(e)},le=e=>{if(H||K){e.preventDefault(),ae(e),ie(e);const t=1===e.deltaMode?12:1;z+=t*(e.deltaY||e.deltaX||0)}M(e)};window.addEventListener("keydown",ne,{passive:!0}),window.addEventListener("keyup",te,{passive:!0}),e.addEventListener("mousedown",re,{passive:!0}),window.addEventListener("mouseup",oe,{passive:!0}),window.addEventListener("mousemove",se,{passive:!0}),e.addEventListener("wheel",le,{passive:!1}),A.config=({defaultMouseDownMoveAction:e=null,isFixed:t=null,isPan:n=null,isPanInverted:o=null,isRotate:r=null,isZoom:u=null,panSpeed:v=null,rotateSpeed:w=null,zoomSpeed:x=null,mouseDownMoveModKey:b=null}={})=>{h=null!==e&&p.includes(e)?e:h,V="pan"===h,i=null!==t?t:i,a=null!==n?n:a,s=null!==o?o:s,c=null!==r?r:c,y=null!==u?u:y,l=+v>0?v:l,d=+w>0?w:d,g=+x>0?x:g,X(),f=null!==b&&Object.keys(m).includes(b)?b:f},A.dispose=()=>{A=void 0,window.removeEventListener("keydown",ne),window.removeEventListener("keyup",te),e.removeEventListener("mousedown",re),window.removeEventListener("mouseup",oe),window.removeEventListener("mousemove",se),e.removeEventListener("wheel",le)},A.refresh=ee,A.tick=()=>{if(i){const e=j;return j=!1,e}N=!1;const e=I,t=R;if((W||Z)&&$&&(V&&!_||!V&&_)){const n=W?Y(l*(q?L-e:e-L)):0,o=Z?U(l*(G?B-t:t-B)):0;0===n&&0===o||(A.pan([n,o]),N=!0)}if((H||K)&&z){const e=g*Math.exp(z/k),t=J(T),n=Q(O);A.scale([H?1/e:1,K?1/e:1],[t,n]),N=!0}if(c&&$&&(V&&_||!V&&!_)&&Math.abs(L-e)+Math.abs(B-t)>0){const n=D/2,o=k/2,r=L-n,i=o-B,a=e-n,s=o-t,l=function(e,t){var n=e[0],o=e[1],r=t[0],i=t[1],a=Math.sqrt(n*n+o*o)*Math.sqrt(r*r+i*i),s=a&&(n*r+o*i)/a;return Math.acos(Math.min(Math.max(s,-1),1))}([r,i],[a,s]),c=r*s-a*i;A.rotate(d*l*Math.sign(c)),N=!0}z=0,L=e,B=t;const n=N||j;return j=!1,n};const ce=e=>function(){e.apply(null,arguments),j=!0};return A.lookAt=ce(A.lookAt),A.translate=ce(A.translate),A.pan=ce(A.pan),A.rotate=ce(A.rotate),A.scale=ce(A.scale),A.zoom=ce(A.zoom),A.reset=ce(A.reset),A.set=ce(A.set),A.setScaleBounds=ce(A.setScaleBounds),A.setTranslationBounds=ce(A.setTranslationBounds),A.setView=ce(A.setView),A.setViewCenter=ce(A.setViewCenter),ee(),A};function f(e,t,n,o,r,i){if(r-o<=n)return;const a=o+r>>1;y(e,t,a,o,r,i%2),f(e,t,n,o,a-1,i+1),f(e,t,n,a+1,r,i+1)}function y(e,t,n,o,r,i){for(;r>o;){if(r-o>600){const a=r-o+1,s=n-o+1,l=Math.log(a),c=.5*Math.exp(2*l/3),d=.5*Math.sqrt(l*c*(a-c)/a)*(s-a/2<0?-1:1);y(e,t,n,Math.max(o,Math.floor(n-s*c/a+d)),Math.min(r,Math.floor(n+(a-s)*c/a+d)),i)}const a=t[2*n+i];let s=o,l=r;for(g(e,t,o,n),t[2*r+i]>a&&g(e,t,o,r);s<l;){for(g(e,t,s,l),s++,l--;t[2*s+i]<a;)s++;for(;t[2*l+i]>a;)l--}t[2*o+i]===a?g(e,t,o,l):(l++,g(e,t,l,r)),l<=n&&(o=l+1),n<=l&&(r=l-1)}}function g(e,t,n,o){v(e,n,o),v(t,2*n,2*o),v(t,2*n+1,2*o+1)}function v(e,t,n){const o=e[t];e[t]=e[n],e[n]=o}function w(e,t,n,o){const r=e-n,i=t-o;return r*r+i*i}const x=e=>e[0],b=e=>e[1];class S{constructor(e,t=x,n=b,o=64,r=Float64Array){this.nodeSize=o,this.points=e;const i=e.length<65536?Uint16Array:Uint32Array,a=this.ids=new i(e.length),s=this.coords=new r(2*e.length);for(let o=0;o<e.length;o++)a[o]=o,s[2*o]=t(e[o]),s[2*o+1]=n(e[o]);f(a,s,o,0,a.length-1,0)}range(e,t,n,o){return function(e,t,n,o,r,i,a){const s=[0,e.length-1,0],l=[];let c,d;for(;s.length;){const u=s.pop(),p=s.pop(),m=s.pop();if(p-m<=a){for(let a=m;a<=p;a++)c=t[2*a],d=t[2*a+1],c>=n&&c<=r&&d>=o&&d<=i&&l.push(e[a]);continue}const h=Math.floor((m+p)/2);c=t[2*h],d=t[2*h+1],c>=n&&c<=r&&d>=o&&d<=i&&l.push(e[h]);const f=(u+1)%2;(0===u?n<=c:o<=d)&&(s.push(m),s.push(h-1),s.push(f)),(0===u?r>=c:i>=d)&&(s.push(h+1),s.push(p),s.push(f))}return l}(this.ids,this.coords,e,t,n,o,this.nodeSize)}within(e,t,n){return function(e,t,n,o,r,i){const a=[0,e.length-1,0],s=[],l=r*r;for(;a.length;){const c=a.pop(),d=a.pop(),u=a.pop();if(d-u<=i){for(let r=u;r<=d;r++)w(t[2*r],t[2*r+1],n,o)<=l&&s.push(e[r]);continue}const p=Math.floor((u+d)/2),m=t[2*p],h=t[2*p+1];w(m,h,n,o)<=l&&s.push(e[p]);const f=(c+1)%2;(0===c?n-r<=m:o-r<=h)&&(a.push(u),a.push(p-1),a.push(f)),(0===c?n+r>=m:o+r>=h)&&(a.push(p+1),a.push(d),a.push(f))}return s}(this.ids,this.coords,e,t,n,this.nodeSize)}}const{push:E,splice:P}=Array.prototype,C=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),M=Float32Array.BYTES_PER_ELEMENT,A={duplicate(e,t=1,n=1){const o=[],r=new Array(2*t);for(let i=0,a=e.length/t;i<a;i++){const a=i*t;for(let o=0;o<t;o++){const i=e[a+o];r[o]=i,r[o+t]=i*n}E.apply(o,r)}return o},mapElement(e,t,n,o){for(let r=0,i=e.length/n;r<i;r++){const i=t+r*n;e[i]=o(e[i],i,r)}return e},copyElement(e,t,n,o){const r=new Array(o),i=t*o;for(let t=0;t<o;t++)r[t]=e[i+t];return P.call(e,n*o,0,...r),e},increaseStride(e,t,n,o=0){const r=[],i=new Array(n).fill(o);for(let n=0,o=e.length/t;n<o;n++){const o=n*t;for(let n=0;n<t;n++)i[n]=e[o+n];E.apply(r,i)}return r}};var I=(e,{projection:t=C,model:n=C,view:o=C,points:r=[],colorIndices:i=[],color:a=[.8,.5,0,1],opacity:l=null,opacities:c=[],width:d=1,widths:u=[],miter:p=1,is2d:m=!1,zPos2d:h=0}={})=>{if(!e)return void console.error("Regl instance is undefined.");const f=new Float32Array(16);let y,g,v,w,x,b,S,E,P,I,R,T,O,L,B,$,z,D,k=m?2:3;const F=()=>+(c.length===g||null!==l),N=()=>{I=e.buffer(),R=e.buffer(),T=e.buffer(),B=e.buffer(),$={prevPosition:{buffer:()=>I,offset:0,stride:3*M},currPosition:{buffer:()=>I,offset:3*M*2,stride:3*M},nextPosition:{buffer:()=>I,offset:3*M*4,stride:3*M},opacity:{buffer:()=>R,offset:2*M,stride:M},offsetScale:{buffer:()=>T,offset:2*M,stride:M},colorIndex:{buffer:()=>B,offset:2*M,stride:M}},z=e.elements(),D=e({attributes:$,depth:{enable:!m},blend:{enable:!0,func:{srcRGB:"src alpha",srcAlpha:"one",dstRGB:"one minus src alpha",dstAlpha:"one minus src alpha"}},uniforms:{projectionViewModel:(e,t)=>{const n=e.projection||t.projection,o=e.model||t.model,r=e.view||t.view;return s(f,n,s(f,r,o))},aspectRatio:({viewportWidth:e,viewportHeight:t})=>e/t,colorTex:()=>O,colorTexRes:()=>L,colorTexEps:()=>.5/L,pixelRatio:({pixelRatio:e})=>e,width:({pixelRatio:e,viewportHeight:t})=>d/t*e,useOpacity:F,useColorOpacity:()=>+!F(),miter:p},elements:()=>z,vert:"\nuniform mat4 projectionViewModel;\nuniform float aspectRatio;\n\nuniform sampler2D colorTex;\nuniform float colorTexRes;\nuniform float colorTexEps;\nuniform float width;\nuniform float useOpacity;\nuniform float useColorOpacity;\nuniform int miter;\n\nattribute vec3 prevPosition;\nattribute vec3 currPosition;\nattribute vec3 nextPosition;\nattribute float opacity;\nattribute float offsetScale;\nattribute float colorIndex;\n\nvarying vec4 color;\n\nvoid main() {\n  vec2 aspectVec = vec2(aspectRatio, 1.0);\n  vec4 prevProjected = projectionViewModel * vec4(prevPosition, 1.0);\n  vec4 currProjected = projectionViewModel * vec4(currPosition, 1.0);\n  vec4 nextProjected = projectionViewModel * vec4(nextPosition, 1.0);\n\n  // get 2D screen space with W divide and aspect correction\n  vec2 prevScreen = prevProjected.xy / prevProjected.w * aspectVec;\n  vec2 currScreen = currProjected.xy / currProjected.w * aspectVec;\n  vec2 nextScreen = nextProjected.xy / nextProjected.w * aspectVec;\n\n  // starting point uses (next - current)\n  vec2 dir = vec2(0.0);\n  if (currScreen == prevScreen) {\n    dir = normalize(nextScreen - currScreen);\n  }\n  // ending point uses (current - previous)\n  else if (currScreen == nextScreen) {\n    dir = normalize(currScreen - prevScreen);\n  }\n  // somewhere in middle, needs a join\n  else {\n    // get directions from (C - B) and (B - A)\n    vec2 dirA = normalize((currScreen - prevScreen));\n    if (miter == 1) {\n      vec2 dirB = normalize((nextScreen - currScreen));\n      // now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      dir = tangent;\n    } else {\n      dir = dirA;\n    }\n  }\n\n  vec2 normal = vec2(-dir.y, dir.x) * width;\n  normal.x /= aspectRatio;\n  vec4 offset = vec4(normal * offsetScale, 0.0, 0.0);\n  gl_Position = currProjected + offset;\n\n  // Get color from texture\n  float colorRowIndex = floor((colorIndex + colorTexEps) / colorTexRes);\n  vec2 colorTexIndex = vec2(\n    (colorIndex / colorTexRes) - colorRowIndex + colorTexEps,\n    colorRowIndex / colorTexRes + colorTexEps\n  );\n\n  color = texture2D(colorTex, colorTexIndex);\n  color.a = useColorOpacity * color.a + useOpacity * opacity;\n}",frag:"\nprecision mediump float;\nvarying vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}"})},j=()=>{_(),N()},_=()=>{r=null,w=null,x=null,E=null,P=null,I.destroy(),T.destroy(),z.destroy()},V=(e,t)=>{const n=t.flat(2);return n.length===g?n:n.length===y?v.map(((e,t)=>Array(e).fill(n[t]))).flat():e},W=(e=[],{colorIndices:t=i,opacities:n=c,widths:o=u,is2d:a=m}={})=>{r=e,k=(m=a)?2:3,y=Array.isArray(r[0])?r.length:1,v=y>1?r.map((e=>Math.floor(e.length/k))):[Math.floor(r.length/k)],g=v.reduce(((e,t)=>e+t),0),i=V(i,t),c=V(c,n),u=V(u,o),r&&g>1?(()=>{1===y&&r.length%k>0&&console.warn(`The length of points (${g}) does not match the dimensions (${k}). Incomplete points are ignored.`),w=r.flat().slice(0,g*k),m&&(w=A.increaseStride(w,2,3,h)),i.length!==g&&(i=new Array(g).fill(0)),u.length!==g&&(u=new Array(g).fill(1));let e=i.slice(),t=c.length===g?c.slice():new Array(g).fill(+l),n=u.slice(),o=0;v.forEach((r=>{const i=o+r-1;A.copyElement(w,i,i,3),A.copyElement(w,o,o,3),A.copyElement(e,i,i,1),A.copyElement(e,o,o,1),A.copyElement(t,i,i,1),A.copyElement(t,o,o,1),A.copyElement(n,i,i,1),A.copyElement(n,o,o,1),o+=r+2})),x=new Float32Array(A.duplicate(w,3)),b=A.duplicate(e),S=A.duplicate(t),E=A.duplicate(n,1,-1),P=((e,t=[])=>{let n=0;return e.forEach((e=>{for(let o=0;o<e-1;o++){const e=n+2*o,r=e+1,i=e+2,a=e+3;t.push(e,r,i,i,r,a)}n+=2*(e+2)})),t})(v),I({usage:"dynamic",type:"float",length:x.length*M,data:x}),R({usage:"dynamic",type:"float",length:S.length*M,data:S}),T({usage:"dynamic",type:"float",length:E.length*M,data:E}),B({usage:"dynamic",type:"float",length:b.length*M,data:b}),z({primitive:"triangles",usage:"dynamic",type:P.length>65536?"uint32":"uint16",data:P})})():j()},Z=(e,t=-1)=>Array.isArray(e)?e.length&&!Array.isArray(e[0])?t+1:Z(e[0],++t):t,q=()=>{const t=0===Z(a)?[a]:a;L=Math.max(2,Math.ceil(Math.sqrt(t.length)));const n=new Uint8Array(L**2*4);t.forEach(((e,t)=>{n[4*t]=Math.min(255,Math.max(0,Math.round(255*e[0]))),n[4*t+1]=Math.min(255,Math.max(0,Math.round(255*e[1]))),n[4*t+2]=Math.min(255,Math.max(0,Math.round(255*e[2]))),n[4*t+3]=Number.isNaN(+e[3])?255:Math.min(255,Math.max(0,Math.round(255*e[3])))})),O=e.texture({data:n,shape:[L,L,4]})};return N(),q(),r&&r.length>1&&W(r),{clear:j,destroy:_,draw:({projection:e,model:i,view:a}={})=>{e&&(t=e),i&&(n=i),a&&(o=a),r&&r.length>1&&D({projection:t,model:n,view:o})},getPoints:()=>r,setPoints:W,getData:()=>({points:x,widths:E,opacities:S,colorIndices:b}),getBuffer:()=>({points:I,widths:T,opacities:R,colorIndices:B}),getStyle:()=>({color:a,miter:p,width:d}),setStyle:({color:e,opacity:t,miter:n,width:o}={})=>{e&&((e,t=l)=>{a=e,l=t,O&&O.destroy(),q()})(e,t),n&&(p=n),+o>0&&(d=o)}}};const R=e=>e<.5?4*e*e*e:(e-1)*(2*e-2)*(2*e-2)+1,T=e=>e,O=(e,t=(e=>e))=>{const n=[];for(let o=0;o<e;o++)n.push(t(o,e));return n},L=(e,...t)=>(t.forEach((t=>{const n=Object.keys(t).reduce(((e,n)=>(e[n]=Object.getOwnPropertyDescriptor(t,n),e)),{});Object.getOwnPropertySymbols(t).forEach((e=>{const o=Object.getOwnPropertyDescriptor(t,e);o.enumerable&&(n[e]=o)})),Object.defineProperties(e,n)})),e),B=(e,t)=>n=>L(n,{get[e](){return t}}),$=(e=1)=>new Promise((t=>{let n=0;const o=()=>requestAnimationFrame((()=>{n++,n<e?o():t()}));o()})),z=(e,t,n=null)=>{let o,r=0;n=null===n?t:n;const i=(...t)=>{clearTimeout(o),o=setTimeout((()=>{r>0&&(e(...t),r=0)}),n)};let a=!1;const s=(...n)=>{a?(r++,i(...n)):(e(...n),i(...n),a=!0,r=0,setTimeout((()=>{a=!1}),t))};return s.reset=()=>{a=!1},s.cancel=()=>{clearTimeout(o)},s.now=(...t)=>e(...t),s},D="auto",k=Float32Array.BYTES_PER_ELEMENT,F=["OES_texture_float","OES_element_index_uint","WEBGL_color_buffer_float","EXT_float_blend"],N={color:[0,0,0,0],depth:1},j="panZoom",_="lasso",V="rotate",W=[j,_,V],Z=j,q={cubicIn:e=>e*e*e,cubicInOut:R,cubicOut:e=>--e*e*e+1,linear:e=>e,quadIn:e=>e*e,quadInOut:e=>e<.5?2*e*e:(4-2*e)*e-1,quadOut:e=>e*(2-e)},G=R,H="continuous",K="categorical",X=[H,K],Y="deselect",U="lassoEnd",J=[Y,U],Q=[0,.666666667,1,1],ee=2,te=!1,ne=10,oe=3,re=U,ie=!1,ae=750,se=500,le=100,ce=250,de="lasso",ue="rotate",pe="merge",me=[de,ue,pe],he="alt",fe="cmd",ye="ctrl",ge="meta",ve="shift",we=[he,fe,ye,ge,ve],xe={[he]:ue,[ve]:de,[fe]:pe},be=D,Se=D,Ee=1,Pe=6,Ce=2,Me=2,Ae=null,Ie=2,Re=2,Te=null,Oe=null,Le=null,Be=.66,$e=null,ze=.15,De=25,ke=1,Fe=1,Ne=null,je=[.66,.66,.66,1],_e=[0,.55,1,1],Ve=[1,1,1,1],We=[0,0,0,1],Ze=null,qe=[.66,.66,.66,.2],Ge=[0,.55,1,1],He=[1,1,1,1],Ke=[0,0],Xe=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),Ye=null,Ue=!1,Je=[1,1,1,.5],Qe=!0,et=!0,tt=!1,nt=100,ot=.002,rt="auto",it=!1,at=new Set(["z","valueZ","valueA","value1","category"]),st=new Set(["w","valueW","valueB","value2","value"]),lt="Points have not been drawn",ct=(e,t)=>!!e&&F.reduce(((n,o)=>e.hasExtension(o)?n:(t||console.warn(`WebGL: ${o} extension not supported. Scatterplot might not render properly`),!1)),!0),dt=e=>{const n=e.getContext("webgl",{antialias:!0,preserveDrawingBuffer:!0}),o=[];return F.forEach((e=>{n.getExtension(e)?o.push(e):console.warn(`WebGL: ${e} extension not supported. Scatterplot might not render properly`)})),t({gl:n,extensions:o})},ut=(e,t,n,o)=>Math.sqrt((e-n)**2+(t-o)**2),pt=(e,t=!1)=>e.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,((e,t,n,o)=>`#${t}${t}${n}${n}${o}${o}`)).substring(1).match(/.{2}/g).map((e=>parseInt(e,16)/255**t)),mt=(e,t,{minLength:n=0}={})=>Array.isArray(e)&&e.length>=n&&e.every(t),ht=e=>!Number.isNaN(+e)&&+e>=0,ft=e=>!Number.isNaN(+e)&&+e>0,yt=(e,t)=>n=>e.indexOf(n)>=0?n:t,gt=(e,t,n=15e3)=>new Promise(((o,r)=>{((e,t=!1,n=15e3)=>new Promise(((o,r)=>{const i=new Image;t&&(i.crossOrigin="anonymous"),i.src=e,i.onload=()=>{o(i)};const a=()=>{r(new Error("IMAGE_LOAD_ERROR"))};i.onerror=a,setTimeout(a,n)})))(t,0!==t.indexOf(window.location.origin)&&-1===t.indexOf("base64"),n).then((t=>{o(e.texture(t))})).catch((e=>{r(e)}))})),vt=e=>e>=0&&e<=1,wt=e=>Array.isArray(e)&&e.every(vt),xt=e=>"string"==typeof e||e instanceof String,bt=e=>Number.isInteger(e)&&e>=0&&e<=255,St=e=>Array.isArray(e)&&e.every(bt),Et=e=>Array.isArray(e)&&e.length&&(Array.isArray(e[0])||xt(e[0])),Pt=(e,t)=>e>t?e:t,Ct=(e,t)=>e<t?e:t,Mt=(e,t)=>{if(4===(n=e).length&&(wt(n)||St(n))){const n=wt(e);return t&&n||!t&&!n?e:t&&!n?e.map((e=>e/255)):e.map((e=>255*e))}var n,o;if(3===(o=e).length&&(wt(o)||St(o))){const n=255**!t,o=wt(e);return t&&o||!t&&!o?[...e,n]:t&&!o?[...e.map((e=>e/255)),n]:[...e.map((e=>255*e)),n]}return/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(e)?((e,t=!1)=>[...pt(e,t),255**!t])(e,t):(console.warn("Only HEX, RGB, and RGBA are handled by this function. Returning white instead."),t?[1,1,1,1]:[255,255,255,255])},At=e=>Object.entries(e).reduce(((e,[t,n])=>(e[n]?e[n]=[...e[n],t]:e[n]=t,e)),{}),It=e=>.21*e[0]+.72*e[1]+.07*e[2],Rt=(e={})=>{let{regl:t,canvas:n=document.createElement("canvas"),gamma:o=Ee}=e;t||(t=dt(n));const r=ct(t),i=[n.width,n.height],a=t.framebuffer({width:i[0],height:i[1],colorFormat:"rgba",colorType:"float"}),s=t({vert:"\n      precision highp float;\n      attribute vec2 xy;\n      void main () {\n        gl_Position = vec4(xy, 0, 1);\n      }",frag:"\n      precision highp float;\n      uniform vec2 srcRes;\n      uniform sampler2D src;\n      uniform float gamma;\n\n      vec3 approxLinearToSRGB (vec3 rgb, float gamma) {\n        return pow(clamp(rgb, vec3(0), vec3(1)), vec3(1.0 / gamma));\n      }\n\n      void main () {\n        vec4 color = texture2D(src, gl_FragCoord.xy / srcRes);\n        gl_FragColor = vec4(approxLinearToSRGB(color.rgb, gamma), color.a);\n      }",attributes:{xy:[-4,-4,4,-4,0,4]},uniforms:{src:()=>a,srcRes:()=>i,gamma:()=>o},count:3,depth:{enable:!1},blend:{enable:!0,func:{srcRGB:"one",srcAlpha:"one",dstRGB:"one minus src alpha",dstAlpha:"one minus src alpha"}}}),l=new Set,c=t.frame((()=>{const e=l.values();let t=e.next();for(;!t.done;)t.value(),t=e.next()})),d=()=>{n.width=window.innerWidth*window.devicePixelRatio,n.height=window.innerHeight*window.devicePixelRatio,i[0]=n.width,i[1]=n.height,a.resize(...i)};e.canvas||(window.addEventListener("resize",d),window.addEventListener("orientationchange",d),d());return{get canvas(){return n},get regl(){return t},get gamma(){return o},set gamma(e){o=+e},get isSupported(){return r},render:(e,o)=>{t.clear(N),a.use((()=>{t.clear(N),e()})),s(),(e=>{const t=e.getContext("2d");t.clearRect(0,0,e.width,e.height),t.drawImage(n,(n.width-e.width)/2,(n.height-e.height)/2,e.width,e.height,0,0,e.width,e.height)})(o)},onFrame:e=>(l.add(e),()=>{l.delete(e)}),refresh:()=>{t.poll()},destroy:()=>{c.cancel(),n=void 0,t=void 0,window.removeEventListener("resize",d),window.removeEventListener("orientationchange",d)}}},Tt=(e,t)=>`${e}ms ease-out effectIn ${t}ms 1 normal forwards`,Ot=(e,t)=>`${e}ms linear leftSpinIn ${t}ms 1 normal forwards`,Lt=(e,t)=>`${e}ms linear rightSpinIn ${t}ms 1 normal forwards`,Bt=(e,t)=>`${e}ms linear circleIn ${t}ms 1 normal forwards`,$t=(e,t,n)=>`\n  @keyframes mainIn {\n    0% {\n      color: ${t};\n      opacity: 0;\n    }\n    0%, ${e}% {\n      color: ${t};\n      opacity: 1;\n    }\n    100% {\n      color: ${n};\n      opacity: 0.8;\n    }\n  }\n`,zt=(e,t,n,o)=>`\n  @keyframes effectIn {\n    0%, ${e}% {\n      opacity: ${n};\n      transform: scale(${o});\n    }\n    ${t}% {\n      opacity: 0.66;\n      transform: scale(1.5);\n    }\n    99% {\n      opacity: 0;\n      transform: scale(2);\n    }\n    100% {\n      opacity: 0;\n      transform: scale(0);\n    }\n  }\n`,Dt=(e,t)=>`\n  @keyframes leftSpinIn {\n    0% {\n      transform: rotate(${t}deg);\n    }\n    ${e}%, 100% {\n      transform: rotate(360deg);\n    }\n  }\n`,kt=(e,t)=>`\n  @keyframes rightSpinIn {\n    0% {\n      transform: rotate(${t}deg);\n    }\n    ${e}%, 100% {\n      transform: rotate(180deg);\n    }\n  }\n`,Ft=e=>`${e}ms linear effectOut 0s 1 normal forwards`,Nt=e=>`${e}ms linear leftSpinOut 0s 1 normal forwards`,jt=e=>`${e}ms linear rightSpinOut 0s 1 normal forwards`,_t=e=>`${e}ms linear circleOut 0s 1 normal forwards`,Vt=(e,t)=>`\n  @keyframes mainOut {\n    0% {\n      color: ${e};\n    }\n    100% {\n      color: ${t};\n    }\n  }\n`,Wt=(e,t)=>`\n  @keyframes rightSpinOut {\n    0%, ${e}% {\n      transform: rotate(${t}deg);\n    }\n    100% {\n      transform: rotate(0deg);\n    }\n`,Zt=e=>`\n  @keyframes leftSpinOut {\n    0% {\n      transform: rotate(${e}deg);\n    }\n    100% {\n      transform: rotate(0deg);\n    }\n  }\n`,qt=(e,t,n)=>`\n  @keyframes circleOut {\n    0%, ${e}% {\n      clip-path: ${t};\n      opacity: ${n};\n    }\n    ${e+.01}% {\n      clip-path: inset(0 0 0 50%);\n      opacity: ${n};\n    }\n    100% {\n      clip-path: inset(0 0 0 50%);\n      opacity: 0;\n    }\n  }\n`,Gt=(e,t=null)=>null===e?t:e;let Ht;const Kt=()=>{if(!Ht){const e=document.createElement("style");document.head.appendChild(e),Ht=e.sheet}return Ht},Xt=e=>{const t=Kt(),n=t.rules.length;return t.insertRule(e,n),n},Yt=e=>{Kt().deleteRule(e)};let Ut=null;let Jt=null;const Qt=(e,{onDraw:t=T,onStart:n=T,onEnd:o=T,enableInitiator:r=true,initiatorParentElement:i=document.body,longPressIndicatorParentElement:a=document.body,minDelay:s=8,minDist:l=2,pointNorm:c=T}={})=>{let d=r,u=i,p=a,m=t,h=n,f=o,y=c;const g=document.createElement("div"),v=Math.random().toString(36).substring(2,5)+Math.random().toString(36).substring(2,5);g.id=`lasso-initiator-${v}`,g.style.position="fixed",g.style.display="flex",g.style.justifyContent="center",g.style.alignItems="center",g.style.zIndex=99,g.style.width="4rem",g.style.height="4rem",g.style.borderRadius="4rem",g.style.opacity=.5,g.style.transform="translate(-50%,-50%) scale(0) rotate(0deg)";const{longPress:w,longPressCircle:x,longPressCircleLeft:b,longPressCircleRight:S,longPressEffect:E}=(()=>{const e=document.createElement("div"),t=Math.random().toString(36).substring(2,5)+Math.random().toString(36).substring(2,5);e.id=`lasso-long-press-${t}`,e.style.position="fixed",e.style.width="1.25rem",e.style.height="1.25rem",e.style.pointerEvents="none",e.style.transform="translate(-50%,-50%)";const n=document.createElement("div");n.style.position="absolute",n.style.top=0,n.style.left=0,n.style.width="1.25rem",n.style.height="1.25rem",n.style.clipPath="inset(0px 0px 0px 50%)",n.style.opacity=0,e.appendChild(n);const o=document.createElement("div");o.style.position="absolute",o.style.top=0,o.style.left=0,o.style.width="0.8rem",o.style.height="0.8rem",o.style.border="0.2rem solid currentcolor",o.style.borderRadius="0.8rem",o.style.clipPath="inset(0px 50% 0px 0px)",o.style.transform="rotate(0deg)",n.appendChild(o);const r=document.createElement("div");r.style.position="absolute",r.style.top=0,r.style.left=0,r.style.width="0.8rem",r.style.height="0.8rem",r.style.border="0.2rem solid currentcolor",r.style.borderRadius="0.8rem",r.style.clipPath="inset(0px 50% 0px 0px)",r.style.transform="rotate(0deg)",n.appendChild(r);const i=document.createElement("div");return i.style.position="absolute",i.style.top=0,i.style.left=0,i.style.width="1.25rem",i.style.height="1.25rem",i.style.borderRadius="1.25rem",i.style.background="currentcolor",i.style.transform="scale(0)",i.style.opacity=0,e.appendChild(i),{longPress:e,longPressCircle:n,longPressCircleLeft:o,longPressCircleRight:r,longPressEffect:i}})();let P,C=!1,M=!1,A=[],I=[],R=!1,O=null,D=null,k=null,F=null,N=null,j=null,_=null,V=null,W=null,Z=null;const q=()=>{C=!1};window.addEventListener("mouseup",q);const G=()=>{g.style.opacity=.5,g.style.transform="translate(-50%,-50%) scale(0) rotate(0deg)"},H=(e,t)=>{const n=getComputedStyle(e),o=+n.opacity,r=n.transform.match(/([0-9.-]+)+/g),i=+r[0],a=+r[1],s=Math.sqrt(i*i+a*a);let l=Math.atan2(a,i)*(180/Math.PI);return l=t&&l<=0?360+l:l,{opacity:o,scale:s,rotate:l}},K=e=>{if(!d||C)return;const t=e.clientX,n=e.clientY;g.style.top=`${n}px`,g.style.left=`${t}px`;const o=H(g),r=o.opacity,i=o.scale,a=o.rotate;g.style.opacity=r,g.style.transform=`translate(-50%,-50%) scale(${i}) rotate(${a}deg)`,g.style.animation="none",$().then((()=>{null!==Ut&&Yt(Ut),Ut=Xt(((e,t,n)=>`\n@keyframes scaleInFadeOut {\n  0% {\n    opacity: ${e};\n    transform: translate(-50%,-50%) scale(${t}) rotate(${n}deg);\n  }\n  10% {\n    opacity: 1;\n    transform: translate(-50%,-50%) scale(1) rotate(${n+20}deg);\n  }\n  100% {\n    opacity: 0;\n    transform: translate(-50%,-50%) scale(0.9) rotate(${n+60}deg);\n  }\n}\n`)(r,i,a)),g.style.animation="2500ms ease scaleInFadeOut 0s 1 normal backwards",$().then((()=>{G()}))}))},X=()=>{const{opacity:e,scale:t,rotate:n}=H(g);g.style.opacity=e,g.style.transform=`translate(-50%,-50%) scale(${t}) rotate(${n}deg)`,g.style.animation="none",$(2).then((()=>{null!==Jt&&Yt(Jt),Jt=Xt(((e,t,n)=>`\n@keyframes fadeScaleOut {\n  0% {\n    opacity: ${e};\n    transform: translate(-50%,-50%) scale(${t}) rotate(${n}deg);\n  }\n  100% {\n    opacity: 0;\n    transform: translate(-50%,-50%) scale(0) rotate(${n}deg);\n  }\n}\n`)(e,t,n)),g.style.animation="250ms ease fadeScaleOut 0s 1 normal backwards",$().then((()=>{G()}))}))},Y=(e,t,{time:n=ae,extraTime:o=se,delay:r=le}={time:ae,extraTime:se,delay:le})=>{R=!0;const i=getComputedStyle(w);w.style.color=i.color,w.style.top=`${t}px`,w.style.left=`${e}px`,w.style.animation="none";const a=getComputedStyle(x);x.style.clipPath=a.clipPath,x.style.opacity=a.opacity,x.style.animation="none";const s=H(E);E.style.opacity=s.opacity,E.style.transform=`scale(${s.scale})`,E.style.animation="none";const l=H(b);b.style.transform=`rotate(${l.rotate}deg)`,b.style.animation="none";const c=H(S);S.style.transform=`rotate(${c.rotate}deg)`,S.style.animation="none",$().then((()=>{if(!R)return;null!==N&&Yt(N),null!==F&&Yt(F),null!==k&&Yt(k),null!==D&&Yt(D),null!==O&&Yt(O);const{rules:e,names:t}=(({time:e=ae,extraTime:t=se,delay:n=le,currentColor:o,targetColor:r,effectOpacity:i,effectScale:a,circleLeftRotation:s,circleRightRotation:l,circleClipPath:c,circleOpacity:d})=>{const u=s/360,p=((e,t,n)=>(1-e)*t+n)(u,e,t),m=Math.round((1-u)*e/p*100),h=Math.round(m/2),f=m+(100-m)/4;return{rules:{main:$t(m,o,r),effect:zt(m,f,i,a),circleRight:kt(h,l),circleLeft:Dt(m,s),circle:(v=h,w=c,x=d,`\n  @keyframes circleIn {\n    0% {\n      clip-path: ${w};\n      opacity: ${x};\n    }\n    ${v}% {\n      clip-path: ${w};\n      opacity: 1;\n    }\n    ${v+.01}%, 100% {\n      clip-path: inset(0);\n      opacity: 1;\n    }\n  }\n`)},names:{main:(y=p,g=n,`${y}ms ease-out mainIn ${g}ms 1 normal forwards`),effect:Tt(p,n),circleLeft:Ot(p,n),circleRight:Lt(p,n),circle:Bt(p,n)}};var y,g,v,w,x})({time:n,extraTime:o,delay:r,currentColor:i.color||"currentcolor",targetColor:w.dataset.activeColor,effectOpacity:s.opacity||0,effectScale:s.scale||0,circleLeftRotation:l.rotate||0,circleRightRotation:c.rotate||0,circleClipPath:a.clipPath||"inset(0 0 0 50%)",circleOpacity:a.opacity||0});O=Xt(e.main),D=Xt(e.effect),k=Xt(e.circleLeft),F=Xt(e.circleRight),N=Xt(e.circle),w.style.animation=t.main,E.style.animation=t.effect,b.style.animation=t.circleLeft,S.style.animation=t.circleRight,x.style.animation=t.circle}))},U=({time:e=ce}={time:ce})=>{if(!R)return;R=!1;const t=getComputedStyle(w);w.style.color=t.color,w.style.animation="none";const n=getComputedStyle(x);x.style.clipPath=n.clipPath,x.style.opacity=n.opacity,x.style.animation="none";const o=H(E);E.style.opacity=o.opacity,E.style.transform=`scale(${o.scale})`,E.style.animation="none";const r="x"===n.clipPath.slice(-2,-1),i=H(b,r);b.style.transform=`rotate(${i.rotate}deg)`,b.style.animation="none";const a=H(S);S.style.transform=`rotate(${a.rotate}deg)`,S.style.animation="none",$().then((()=>{null!==Z&&Yt(Z),null!==W&&Yt(W),null!==V&&Yt(V),null!==_&&Yt(_),null!==j&&Yt(j);const{rules:r,names:s}=(({time:e=ce,currentColor:t,targetColor:n,effectOpacity:o,effectScale:r,circleLeftRotation:i,circleRightRotation:a,circleClipPath:s,circleOpacity:l})=>{const c=i/360,d=c*e,u=Math.min(100,100*c),p=u>50?Math.round(100*(1-50/u)):0;return{rules:{main:Vt(t,n),effect:(h=o,f=r,`\n  @keyframes effectOut {\n    0% {\n      opacity: ${h};\n      transform: scale(${f});\n    }\n    99% {\n      opacity: 0;\n      transform: scale(${f+.5});\n    }\n    100% {\n      opacity: 0;\n      transform: scale(0);\n    }\n  }\n`),circleRight:Wt(p,a),circleLeft:Zt(i),circle:qt(p,s,l)},names:{main:(m=d,`${m}ms linear mainOut 0s 1 normal forwards`),effect:Ft(d),circleRight:Nt(d),circleLeft:jt(d),circle:_t(d)}};var m,h,f})({time:e,currentColor:t.color||"currentcolor",targetColor:w.dataset.color,effectOpacity:o.opacity||0,effectScale:o.scale||0,circleLeftRotation:i.rotate||0,circleRightRotation:a.rotate||0,circleClipPath:n.clipPath||"inset(0px)",circleOpacity:n.opacity||1});j=Xt(r.main),_=Xt(r.effect),V=Xt(r.circleLeft),W=Xt(r.circleRight),Z=Xt(r.circle),w.style.animation=s.main,E.style.animation=s.effect,b.style.animation=s.circleLeft,S.style.animation=s.circleRight,x.style.animation=s.circle}))},J=()=>{m(A,I)},Q=e=>{if(P){if((t=e[0],n=e[1],o=P[0],r=P[1],Math.sqrt((t-o)**2+(n-r)**2))>2){P=e;const t=y(e);A.push(t),I.push(t[0],t[1]),A.length>1&&J()}}else{M||(M=!0,h()),P=e;const t=y(e);A=[t],I=[t[0],t[1]]}var t,n,o,r},ee=z(Q,8,8),te=(t,n)=>{const o=(t=>{const{left:n,top:o}=e.getBoundingClientRect();return[t.clientX-n,t.clientY-o]})(t);return n?ee(o):Q(o)},ne=()=>{A=[],I=[],P=void 0,J()},oe=e=>{K(e)},re=()=>{C=!0,M=!0,ne(),h()},ie=()=>{X()},de=({merge:e=!1}={})=>{M=!1;const t=[...A],n=[...I];return ee.cancel(),ne(),t.length&&f(t,n,{merge:e}),t},ue=({onDraw:e=null,onStart:t=null,onEnd:n=null,enableInitiator:o=null,initiatorParentElement:r=null,longPressIndicatorParentElement:i=null,minDelay:a=null,minDist:s=null,pointNorm:l=null}={})=>{m=Gt(e,m),h=Gt(t,h),f=Gt(n,f),d=Gt(o,d),y=Gt(l,y),null!==r&&r!==u&&(u.removeChild(g),r.appendChild(g),u=r),null!==i&&i!==p&&(p.removeChild(w),i.appendChild(w),p=i),d?(g.addEventListener("click",oe),g.addEventListener("mousedown",re),g.addEventListener("mouseleave",ie)):(g.removeEventListener("mousedown",re),g.removeEventListener("mouseleave",ie))},pe=()=>{u.removeChild(g),p.removeChild(w),window.removeEventListener("mouseup",q),g.removeEventListener("click",oe),g.removeEventListener("mousedown",re),g.removeEventListener("mouseleave",ie)};return u.appendChild(g),p.appendChild(w),ue({onDraw:m,onStart:h,onEnd:f,enableInitiator:d,initiatorParentElement:u}),((...e)=>t=>e.reduce(((e,t)=>t(e)),t))(B("initiator",g),B("longPressIndicator",w),(e=>L(e,{clear:ne,destroy:pe,end:de,extend:te,set:ue,showInitiator:K,hideInitiator:X,showLongPressIndicator:Y,hideLongPressIndicator:U})),(me=Qt,e=>L({__proto__:{constructor:me}},e)))({});var me},en=e=>`\nprecision highp float;\n\nuniform sampler2D colorTex;\nuniform float colorTexRes;\nuniform float colorTexEps;\nuniform sampler2D stateTex;\nuniform float stateTexRes;\nuniform float stateTexEps;\nuniform float devicePixelRatio;\nuniform sampler2D encodingTex;\nuniform float encodingTexRes;\nuniform float encodingTexEps;\nuniform float pointSizeExtra;\nuniform float pointOpacityMax;\nuniform float pointOpacityScale;\nuniform float numPoints;\nuniform float globalState;\nuniform float isColoredByZ;\nuniform float isColoredByW;\nuniform float isOpacityByZ;\nuniform float isOpacityByW;\nuniform float isOpacityByDensity;\nuniform float isSizedByZ;\nuniform float isSizedByW;\nuniform float colorMultiplicator;\nuniform float opacityMultiplicator;\nuniform float opacityDensity;\nuniform float sizeMultiplicator;\nuniform float numColorStates;\nuniform float pointScale;\nuniform mat4 modelViewProjection;\n\nattribute vec2 stateIndex;\n\nvarying vec4 color;\nvarying float finalPointSize;\n\nvoid main() {\n  vec4 state = texture2D(stateTex, stateIndex);\n\n  gl_Position = modelViewProjection * vec4(state.x, state.y, 0.0, 1.0);\n\n  // Determine color index\n  float colorIndexZ =  isColoredByZ * floor(state.z * colorMultiplicator);\n  float colorIndexW =  isColoredByW * floor(state.w * colorMultiplicator);\n\n  // Multiply by the number of color states per color\n  // I.e., normal, active, hover, background, etc.\n  float colorIndex = (colorIndexZ + colorIndexW) * numColorStates;\n\n  // Half a "pixel" or "texel" in texture coordinates\n  float colorLinearIndex = colorIndex + globalState;\n\n  // Need to add cEps here to avoid floating point issue that can lead to\n  // dramatic changes in which color is loaded as floor(3/2.9999) = 1 but\n  // floor(3/3.0001) = 0!\n  float colorRowIndex = floor((colorLinearIndex + colorTexEps) / colorTexRes);\n\n  vec2 colorTexIndex = vec2(\n    (colorLinearIndex / colorTexRes) - colorRowIndex + colorTexEps,\n    colorRowIndex / colorTexRes + colorTexEps\n  );\n\n  color = texture2D(colorTex, colorTexIndex);\n\n  // Retrieve point size\n  float pointSizeIndexZ = isSizedByZ * floor(state.z * sizeMultiplicator);\n  float pointSizeIndexW = isSizedByW * floor(state.w * sizeMultiplicator);\n  float pointSizeIndex = pointSizeIndexZ + pointSizeIndexW;\n\n  float pointSizeRowIndex = floor((pointSizeIndex + encodingTexEps) / encodingTexRes);\n  vec2 pointSizeTexIndex = vec2(\n    (pointSizeIndex / encodingTexRes) - pointSizeRowIndex + encodingTexEps,\n    pointSizeRowIndex / encodingTexRes + encodingTexEps\n  );\n  float pointSize = texture2D(encodingTex, pointSizeTexIndex).x;\n\n  // Retrieve opacity\n  ${3===e?"":`\n        if (isOpacityByDensity < 0.5) {\n          float opacityIndexZ = isOpacityByZ * floor(state.z * opacityMultiplicator);\n          float opacityIndexW = isOpacityByW * floor(state.w * opacityMultiplicator);\n          float opacityIndex = opacityIndexZ + opacityIndexW;\n\n          float opacityRowIndex = floor((opacityIndex + encodingTexEps) / encodingTexRes);\n          vec2 opacityTexIndex = vec2(\n            (opacityIndex / encodingTexRes) - opacityRowIndex + encodingTexEps,\n            opacityRowIndex / encodingTexRes + encodingTexEps\n          );\n          color.a = texture2D(encodingTex, opacityTexIndex)[${1+e}];\n        } else {\n          color.a = min(1.0, opacityDensity + globalState);\n        }\n      `}\n\n  color.a = min(pointOpacityMax, color.a) * pointOpacityScale;\n  finalPointSize = (pointSize * pointScale) + pointSizeExtra;\n  gl_PointSize = finalPointSize;\n}\n`,tn=function(){const e=(e,t,n,o,r)=>{const i=.5*(o-t),a=.5*(r-n);return(2*n-2*o+i+a)*e*e*e+(-3*n+3*o-2*i-a)*e*e+i*e+n},t=(t,n,o)=>{const r=o*t,i=Math.floor(r),a=r-i,s=n[Math.max(0,i-1)],l=n[i],c=n[Math.min(o,i+1)],d=n[Math.min(o,i+2)];return[e(a,s[0],l[0],c[0],d[0]),e(a,s[1],l[1],c[1],d[1])]},n=(e,t,n)=>{let o=t[0],r=t[1],i=n[0]-o,a=n[1]-r;if(0!==i||0!==a){const t=((e[0]-o)*i+(e[1]-r)*a)/(i*i+a*a);t>1?(o=n[0],r=n[1]):t>0&&(o+=i*t,r+=a*t)}return i=e[0]-o,a=e[1]-r,i*i+a*a},o=(e,t,r,i,a)=>{let s,l=i;for(let o=t+1;o<r;o++){const i=n(e[o],e[t],e[r]);i>l&&(s=o,l=i)}l>i&&(s-t>1&&o(e,t,s,i,a),a.push(e[s]),r-s>1&&o(e,s,r,i,a))},r=(e,t)=>{const n=e.length-1,r=[e[0]];return o(e,0,n,t,r),r.push(e[n]),r};self.onmessage=function(e){(e.data.points?+e.data.points.length:0)||self.postMessage({error:new Error("No points provided")}),e.data.points;const n=(e=>{const t={},n=!Number.isNaN(+e[0][5]);return e.forEach((e=>{const o=e[4];t[o]||(t[o]=[]),n?t[o][e[5]]=e:t[o].push(e)})),Object.entries(t).forEach((e=>{t[e[0]]=e[1].filter((e=>e)),t[e[0]].reference=e[1][0]})),t})(e.data.points);self.postMessage({points:Object.entries(n).reduce(((n,o)=>(n[o[0]]=((e,{maxIntPointsPerSegment:n=100,tolerance:o=.002}={})=>{const i=e.length,a=i-1,s=a*n+1,l=o**2;let c,d=[];for(let o=0;o<i-1;o++){let i=[e[o].slice(0,2)];c=e[o];for(let r=1;r<n;r++){const d=t((o*n+r)/s,e,a);u=c[0],p=c[1],(u-d[0])**2+(p-d[1])**2>l&&(i.push(d),c=d)}i.push(e[o+1]),i=r(i,l),d=d.concat(i.slice(0,i.length-1))}var u,p;
/**
   * Douglas Peucker square segment distance
   * Implementation from https://github.com/mourner/simplify-js
   * @author Vladimir Agafonkin
   * @copyright Vladimir Agafonkin 2013
   * @license BSD
   * @param {array} p - Point
   * @param {array} p1 - First boundary point
   * @param {array} p2 - Second boundary point
   * @return {number} Distance
   */return d.push(e[e.length-1].slice(0,2)),d.flat()})(o[1],e.data.options),n[o[0]].reference=o[1].reference,n)),{})})}},nn=(e,t={tolerance:.002,maxIntPointsPerSegment:100})=>new Promise(((n,o)=>{const r=(i=tn,new Worker(window.URL.createObjectURL(new Blob([`(${i.toString()})()`],{type:"text/javascript"}))));var i;r.onmessage=e=>{e.data.error?o(e.data.error):n(e.data.points),r.terminate()},r.postMessage({points:e,options:t})}));const on={showRecticle:"showReticle",recticleColor:"reticleColor"},rn=e=>{Object.keys(e).filter((e=>on[e])).forEach((t=>{console.warn(`regl-scatterplot: the "${t}" property is deprecated. Please use "${on[t]}" instead.`),e[on[t]]=e[t],delete e[t]}))},an=(e,t,{allowSegment:n=!1,allowDensity:o=!1}={})=>at.has(e)?"valueZ":st.has(e)?"valueW":"segment"===e?n?"segment":t:"density"===e&&o?"density":t,sn=e=>{switch(e){case"valueZ":return 2;case"valueW":return 3;default:return null}},ln=(t={})=>{const n=e({async:!t.syncEvents,caseInsensitive:!0}),o=new Float32Array(16),r=new Float32Array(16),l=[0,0];rn(t);let{renderer:u,backgroundColor:p=We,backgroundImage:m=Ye,canvas:f=document.createElement("canvas"),colorBy:y=Ne,deselectOnDblClick:g=Qe,deselectOnEscape:v=et,lassoColor:w=Q,lassoLineWidth:x=ee,lassoMinDelay:b=ne,lassoMinDist:E=oe,lassoClearEvent:P=re,lassoInitiator:C=te,lassoInitiatorParentElement:M=document.body,lassoOnLongPress:A=ie,lassoLongPressTime:R=ae,lassoLongPressAfterEffectTime:L=se,lassoLongPressEffectDelay:B=le,lassoLongPressRevertEffectTime:$=ce,keyMap:F=xe,mouseMode:N=Z,showReticle:Ee=Ue,reticleColor:ct=Je,pointColor:dt=je,pointColorActive:pt=_e,pointColorHover:vt=Ve,showPointConnections:wt=tt,pointConnectionColor:bt=qe,pointConnectionColorActive:St=Ge,pointConnectionColorHover:Tt=He,pointConnectionColorBy:Ot=Ze,pointConnectionOpacity:Lt=Oe,pointConnectionOpacityBy:Bt=Le,pointConnectionOpacityActive:$t=Be,pointConnectionSize:zt=Ie,pointConnectionSizeActive:Dt=Re,pointConnectionSizeBy:kt=Te,pointConnectionMaxIntPointsPerSegment:Ft=nt,pointConnectionTolerance:Nt=ot,pointSize:jt=Pe,pointSizeSelected:_t=Ce,pointSizeMouseDetection:Vt=rt,pointOutlineWidth:Wt=Me,opacity:Zt=D,opacityBy:qt=$e,opacityByDensityFill:Gt=ze,opacityInactiveMax:Ht=ke,opacityInactiveScale:Kt=Fe,sizeBy:Xt=Ae,height:Yt=Se,width:Ut=be}=t,Jt=Ut===D?1:Ut,tn=Yt===D?1:Yt;const{performanceMode:on=it,opacityByDensityDebounceTime:ln=De}=t;u||(u=Rt({regl:t.regl,gamma:t.gamma})),p=Mt(p,!0),w=Mt(w,!0),ct=Mt(ct,!0);let cn,dn,un=!1,pn=It(p),mn=!1,hn=null,fn=[0,0],yn=-1,gn=[];const vn=new Set,wn=new Set;let xn=!1;const bn=new Set;let Sn,En,Pn,Cn,Mn,An,In,Rn,Tn,On,Ln,Bn,$n,zn,Dn,kn=0,Fn=0,Nn=!1,jn=[],_n=t.aspectRatio||1,Vn=At(F),Wn=!1,Zn=!0,qn=!1;dt=Et(dt)?[...dt]:[dt],pt=Et(pt)?[...pt]:[pt],vt=Et(vt)?[...vt]:[vt],dt=dt.map((e=>Mt(e,!0))),pt=pt.map((e=>Mt(e,!0))),vt=vt.map((e=>Mt(e,!0))),Zt=!Array.isArray(Zt)&&Number.isNaN(+Zt)?dt[0][3]:Zt,Zt=mt(Zt,ht,{minLength:1})?[...Zt]:[Zt],jt=mt(jt,ht,{minLength:1})?[...jt]:[jt];let Gn,Hn,Kn,Xn,Yn=1/jt[0];"inherit"===bt?bt=[...dt]:(bt=Et(bt)?[...bt]:[bt],bt=bt.map((e=>Mt(e,!0)))),"inherit"===St?St=[...pt]:(St=Et(St)?[...St]:[St],St=St.map((e=>Mt(e,!0)))),"inherit"===Tt?Tt=[...vt]:(Tt=Et(Tt)?[...Tt]:[Tt],Tt=Tt.map((e=>Mt(e,!0)))),Lt="inherit"===Lt?[...Zt]:mt(Lt,ht,{minLength:1})?[...Lt]:[Lt],zt="inherit"===zt?[...jt]:mt(zt,ht,{minLength:1})?[...zt]:[zt],y=an(y,Ne),qt=an(qt,$e,{allowDensity:!0}),Xt=an(Xt,Ae),Ot=an(Ot,Ze,{allowSegment:!0}),Bt=an(Bt,Le,{allowSegment:!0}),kt=an(kt,Te,{allowSegment:!0});let Un,Jn,Qn,eo,to,no,oo,ro,io,ao,so,lo,co=0,uo=0,po=!1,mo=null,ho=Ee,fo=0,yo=0,go=!1,vo=!1,wo=!1,xo=K,bo=K,So=!1,Eo=t.xScale||null,Po=t.yScale||null,Co=0,Mo=0,Ao=0,Io=0;Eo&&(Co=Eo.domain()[0],Mo=Eo.domain()[1]-Eo.domain()[0],Eo.range([0,Jt])),Po&&(Ao=Po.domain()[0],Io=Po.domain()[1]-Po.domain()[0],Po.range([tn,0]));const Ro=e=>e/Jt*2-1,To=e=>1+e/tn*-2,Oo=(e,t)=>{const n=[e,t,1,1];return d(n,n,a(o,s(o,Pn,s(o,cn.view,Mn)))),n.slice(0,2)},Lo=(e=0)=>{const t=Or(),n=($n[1]-zn[1])/f.height;return(Ln*t+e)*n},Bo=()=>xn?Sn.points.filter(((e,t)=>bn.has(t))):Sn.points,$o=(e,t,n,o)=>{const r=Sn.range(e,t,n,o);return xn?r.filter((e=>bn.has(e))):r},zo=()=>{const[e,t]=[Ro(l[0]),To(l[1])],[n,o]=Oo(e,t),r=Lo(4),i=$o(n-r,o-r,n+r,o+r);let a=r,s=-1;return i.forEach((e=>{const[t,r]=Sn.points[e],i=ut(t,r,n,o);i<a&&(a=i,s=e)})),s},Do=e=>{const t=(e=>{let t=1/0,n=-1/0,o=1/0,r=-1/0;for(let i=0;i<e.length;i+=2)t=e[i]<t?e[i]:t,n=e[i]>n?e[i]:n,o=e[i+1]<o?e[i+1]:o,r=e[i+1]>r?e[i+1]:r;return[t,o,n,r]})(e);if(!(([e,t,n,o])=>Number.isFinite(e)&&Number.isFinite(t)&&Number.isFinite(n)&&Number.isFinite(o)&&n-e>0&&o-t>0)(t))return[];const n=$o(...t),o=[];return n.forEach((t=>{((e,[t,n]=[])=>{let o,r,i,a,s=!1;for(let l=0,c=e.length-2;l<e.length;l+=2)o=e[l],r=e[l+1],i=e[c],a=e[c+1],r>n!=a>n&&t<(i-o)*(n-r)/(a-r)+o&&(s=!s),c=l;return s})(e,Sn.points[t])&&o.push(t)})),o},ko=()=>{jn=[],dn&&dn.clear()},Fo=e=>e&&e.length>4,No=(e,t)=>{if(Rn||!wt||!Fo(Sn.points[e[0]]))return;const n=0===t,o=1===t?e=>wn.add(e):T,r=Object.keys(e.reduce(((e,t)=>{const n=Sn.points[t];return e[Array.isArray(n[4])?n[4][0]:n[4]]=!0,e}),{})),i=An.getData().opacities;r.filter((e=>!wn.has(+e))).forEach((e=>{const t=In[e][0],r=In[e][2],a=4*t+2*In[e][3],s=a+2*r+4;void 0===i.__original__&&(i.__original__=i.slice());for(let e=a;e<s;e++)i[e]=n?i.__original__[e]:$t;o(e)})),An.getBuffer().opacities.subdata(i,0)},jo=e=>[e%co/co+uo,Math.floor(e/co)/co+uo],_o=e=>xn&&!bn.has(e),Vo=({preventEvent:e=!1}={})=>{P===Y&&ko(),gn.length&&(e||n.publish("deselect"),wn.clear(),No(gn,0),gn=[],vn.clear(),Zn=!0)},Wo=(e,{merge:t=!1,preventEvent:o=!1}={})=>{const r=Array.isArray(e)?e:[e],i=[...gn];if(t){if(gn=((e,t)=>{const n=[];return e.forEach((e=>{n[e]=!0})),t.forEach((e=>{n[e]=!0})),n.reduce(((e,t,n)=>(t&&e.push(n),e)),[])})(gn,r),i.length===gn.length)return void(Zn=!0)}else{if(gn&&gn.length&&No(gn,0),i.length>0&&0===r.length)return void Vo({preventEvent:o});gn=r}if(((e,t)=>{if(e===t)return!0;if(e.length!==t.length)return!1;const n=new Set(e),o=new Set(t);return n.size===o.size&&t.every((e=>n.has(e)))})(i,gn))return void(Zn=!0);const a=[];vn.clear(),wn.clear();for(let e=gn.length-1;e>=0;e--){const t=gn[e];t<0||t>=kn||_o(t)?gn.splice(e,1):(vn.add(t),a.push.apply(a,jo(t)))}Jn({usage:"dynamic",type:"float",data:a}),No(gn,1),o||n.publish("select",{points:gn}),Zn=!0},Zo=(e,{showReticleOnce:t=!1,preventEvent:o=!1}={})=>{let r=!1;if(e>=0&&e<kn){r=!0;const t=lo,i=e!==lo;+t>=0&&i&&!vn.has(t)&&No([t],0),lo=e,Qn.subdata(jo(e)),vn.has(e)||No([e],2),i&&!o&&n.publish("pointover",lo)}else r=+lo>=0,r&&(vn.has(lo)||No([lo],0),o||n.publish("pointout",lo)),lo=void 0;r&&(Zn=!0,qn=t)},qo=e=>{const t=f.getBoundingClientRect();return l[0]=e.clientX-t.left,l[1]=e.clientY-t.top,[...l]},Go=Qt(f,{onStart:()=>{cn.config({isFixed:!0}),mn=!0,Nn=!0,ko(),yn>=0&&(clearTimeout(yn),yn=-1),n.publish("lassoStart")},onDraw:(e,t)=>{jn=e,dn.setPoints(t),n.publish("lassoExtend",{coordinates:e})},onEnd:(e,t,{merge:o=!1}={})=>{cn.config({isFixed:!1}),jn=[...e];const r=Do(t);Wo(r,{merge:o}),n.publish("lassoEnd",{coordinates:jn}),P===U&&ko()},enableInitiator:C,initiatorParentElement:M,pointNorm:([e,t])=>Oo(Ro(e),To(t))}),Ho=(e,t)=>{switch(Vn[t]){case he:return e.altKey;case fe:return e.metaKey;case ye:return e.ctrlKey;case ge:return e.metaKey;case ve:return e.shiftKey;default:return!1}},Ko=e=>{vo&&1===e.buttons&&(mn=!0,hn=performance.now(),fn=qo(e),Nn=N===_||Ho(e,de),!Nn&&A&&(Go.showLongPressIndicator(e.clientX,e.clientY,{time:R,extraTime:L,delay:B}),yn=setTimeout((()=>{yn=-1,Nn=!0}),R)))},Xo=e=>{vo&&(mn=!1,yn>=0&&(clearTimeout(yn),yn=-1),Nn&&(e.preventDefault(),Nn=!1,Go.end({merge:Ho(e,pe)})),A&&Go.hideLongPressIndicator({time:$}))},Yo=e=>{if(!vo)return;e.preventDefault();const t=qo(e);if(ut(...t,...fn)>=E)return;const n=performance.now()-hn;if(!C||n<500){const t=zo();t>=0?(gn.length&&P===Y&&ko(),Wo([t],{merge:Ho(e,pe)})):Bn||(Bn=setTimeout((()=>{Bn=null,Go.showInitiator(e)}),200))}},Uo=e=>{Go.hideInitiator(),Bn&&(clearTimeout(Bn),Bn=null),g&&(e.preventDefault(),Vo())},Jo=e=>{if(wo||(So=(e=>document.elementsFromPoint(e.clientX,e.clientY).some((e=>e===f)))(e),wo=!0),!vo||!So&&!mn)return;const t=qo(e),n=ut(...t,...fn)>=E;So&&!Nn&&Zo(zo()),Nn?(e.preventDefault(),Go.extend(e,!0)):mn&&A&&n&&Go.hideLongPressIndicator({time:$}),yn>=0&&n&&(clearTimeout(yn),yn=-1),mn&&(Zn=!0)},Qo=()=>{lo=void 0,So=!1,wo=!1,vo&&(+lo>=0&&!vn.has(lo)&&No([lo],0),Xo(),Zn=!0)},er=()=>{const e=Math.max(jt.length,Zt.length);yo=Math.max(2,Math.ceil(Math.sqrt(e)));const t=new Float32Array(yo**2*4);for(let n=0;n<e;n++){t[4*n]=jt[n]||0,t[4*n+1]=Math.min(1,Zt[n]||0);const e=Number((pt[n]||pt[0])[3]);t[4*n+2]=Math.min(1,Number.isNaN(e)?1:e);const o=Number((vt[n]||vt[0])[3]);t[4*n+3]=Math.min(1,Number.isNaN(o)?1:o)}return u.regl.texture({data:t,shape:[yo,yo,4],type:"float"})},tr=(e=dt,t=pt,n=vt)=>{const o=e.length,r=t.length,i=n.length,a=[];if(o===r&&r===i)for(let r=0;r<o;r++)a.push(e[r],t[r],n[r],p);else for(let r=0;r<o;r++){const o=[e[r][0],e[r][1],e[r][2],1],i=y===Ne?t[0]:o,s=y===Ne?n[0]:o;a.push(e[r],i,s,p)}return a},nr=()=>{const e=tr(),t=e.length;fo=Math.max(2,Math.ceil(Math.sqrt(t)));const n=new Float32Array(fo**2*4);return e.forEach(((e,t)=>{n[4*t]=e[0],n[4*t+1]=e[1],n[4*t+2]=e[2],n[4*t+3]=e[3]})),u.regl.texture({data:n,shape:[fo,fo,4],type:"float"})},or=()=>{En=Jt/tn,Pn=c([],[1/En,1,1]),Cn=c([],[1/En,1,1]),Mn=c([],[_n,1,1])},rr=(e,t)=>n=>{if(!n||!n.length)return;const o=[...e()];let r=Et(n)?n:[n];r=r.map((e=>Mt(e,!0))),ao&&ao.destroy();try{t(r),ao=nr()}catch(e){console.error("Invalid colors. Switching back to default colors."),t(o),ao=nr()}},ir=rr((()=>dt),(e=>{dt=e})),ar=rr((()=>pt),(e=>{pt=e})),sr=rr((()=>vt),(e=>{vt=e})),lr=()=>{if(!Eo&&!Po)return;const[e,t]=(()=>{const e=Oo(-1,-1),t=Oo(1,1),n=(e[0]+1)/2,o=(t[0]+1)/2,r=(e[1]+1)/2,i=(t[1]+1)/2;return[[Co+n*Mo,Co+o*Mo],[Ao+r*Io,Ao+i*Io]]})();Eo&&Eo.domain(e),Po&&Po.domain(t)},cr=e=>{tn=Math.max(1,e),f.height=Math.floor(tn*window.devicePixelRatio),Po&&(Po.range([tn,0]),lr())},dr=()=>{Ln=Vt,Vt===D&&(Ln=Array.isArray(jt)?jt.reduce(((e,t)=>t>e?t:e),-1/0):jt)},ur=e=>{Jt=Math.max(1,e),f.width=Math.floor(Jt*window.devicePixelRatio),Eo&&(Eo.range([0,Jt]),lr())},pr=e=>{switch(e){case"valueZ":return xo;case"valueW":return bo;default:return null}},mr=(e,t)=>e===H?e=>Math.round(e*(t.length-1)):T,hr=()=>[f.width,f.height],fr=()=>ao,yr=()=>fo,gr=()=>.5/fo,vr=()=>window.devicePixelRatio,wr=()=>Jn,xr=()=>so,br=()=>yo,Sr=()=>.5/yo,Er=()=>0,Pr=()=>Kn||Gn,Cr=()=>co,Mr=()=>.5/co,Ar=()=>Cn,Ir=()=>cn.view,Rr=()=>Mn,Tr=()=>s(r,Cn,s(r,cn.view,Mn)),Or=()=>cn.scaling[0]>1?Math.asinh(Pt(1,cn.scaling[0]))/Math.asinh(1)*window.devicePixelRatio:Pt(Yn,cn.scaling[0])*window.devicePixelRatio,Lr=()=>gn.length,Br=()=>Lr()>0?Ht:1,$r=()=>Lr()>0?Kt:1,zr=()=>+("valueZ"===y),Dr=()=>+("valueW"===y),kr=()=>+("valueZ"===qt),Fr=()=>+("valueW"===qt),Nr=()=>+("density"===qt),jr=()=>+("valueZ"===Xt),_r=()=>+("valueW"===Xt),Vr=()=>"valueZ"===y?xo===H?dt.length-1:1:bo===H?dt.length-1:1,Wr=()=>"valueZ"===qt?xo===H?Zt.length-1:1:bo===H?Zt.length-1:1,Zr=()=>"valueZ"===Xt?xo===H?jt.length-1:1:bo===H?jt.length-1:1,qr=e=>{if("density"!==qt)return 1;const t=Or(),n=jt[0]*t,o=2/(2/cn.view[0])*(2/(2/cn.view[5])),r=e.viewportHeight,i=e.viewportWidth;let a=Gt*i*r/(Fn*n*n)*Ct(1,o);a*=on?1:1/(.25*Math.PI);return a*=(n/(Pt(1,n)+.5))**2,Ct(1,Pt(0,a))},Gr=u.regl({framebuffer:()=>Xn,vert:"precision highp float;\n\nattribute vec2 position;\nvarying vec2 particleTextureIndex;\n\nvoid main() {\n  // map normalized device coords to texture coords\n  particleTextureIndex = 0.5 * (1.0 + position);\n\n  gl_Position = vec4(position, 0, 1);\n}",frag:"precision highp float;\n\nuniform sampler2D startStateTex;\nuniform sampler2D endStateTex;\nuniform float t;\n\nvarying vec2 particleTextureIndex;\n\nvoid main() {\n  // Interpolate x, y, and value\n  vec3 start = texture2D(startStateTex, particleTextureIndex).xyw;\n  vec3 end = texture2D(endStateTex, particleTextureIndex).xyw;\n  vec3 curr = start * (1.0 - t) + end * t;\n\n  // The category cannot be interpolated\n  float endCategory = texture2D(endStateTex, particleTextureIndex).z;\n\n  gl_FragColor = vec4(curr.xy, endCategory, curr.z);\n}",attributes:{position:[-4,0,4,4,4,-4]},uniforms:{startStateTex:()=>Hn,endStateTex:()=>Gn,t:(e,t)=>t.t},count:3}),Hr=(e,t,n,o=0,r=Br,i=$r)=>u.regl({frag:on?"precision highp float;\n\nvarying vec4 color;\n\nvoid main() {\n  gl_FragColor = color;\n}\n":"\nprecision highp float;\n\nvarying vec4 color;\nvarying float finalPointSize;\n\nfloat linearstep(float edge0, float edge1, float x) {\n  return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nvoid main() {\n  vec2 c = gl_PointCoord * 2.0 - 1.0;\n  float sdf = length(c) * finalPointSize;\n  float alpha = linearstep(finalPointSize + 0.5, finalPointSize - 0.5, sdf);\n\n  gl_FragColor = vec4(color.rgb, alpha * color.a);\n}\n",vert:en(o),blend:{enable:!on,func:{srcRGB:"src alpha",srcAlpha:"one",dstRGB:"one minus src alpha",dstAlpha:"one minus src alpha"}},depth:{enable:!1},attributes:{stateIndex:{buffer:n,size:2}},uniforms:{resolution:hr,modelViewProjection:Tr,devicePixelRatio:vr,pointScale:Or,encodingTex:xr,encodingTexRes:br,encodingTexEps:Sr,pointOpacityMax:r,pointOpacityScale:i,pointSizeExtra:e,globalState:o,colorTex:fr,colorTexRes:yr,colorTexEps:gr,stateTex:Pr,stateTexRes:Cr,stateTexEps:Mr,isColoredByZ:zr,isColoredByW:Dr,isOpacityByZ:kr,isOpacityByW:Fr,isOpacityByDensity:Nr,isSizedByZ:jr,isSizedByW:_r,colorMultiplicator:Vr,opacityMultiplicator:Wr,opacityDensity:qr,sizeMultiplicator:Zr,numColorStates:4},count:t,primitive:"points"}),Kr=Hr(Er,(()=>xn?bn.size:kn),(()=>Un)),Xr=Hr(Er,(()=>1),(()=>Qn),2,(()=>1),(()=>1)),Yr=Hr((()=>(_t+2*Wt)*window.devicePixelRatio),Lr,wr,1,(()=>1),(()=>1)),Ur=Hr((()=>(_t+Wt)*window.devicePixelRatio),Lr,wr,3,(()=>1),(()=>1)),Jr=Hr((()=>_t*window.devicePixelRatio),Lr,wr,1,(()=>1),(()=>1)),Qr=u.regl({frag:"\nprecision mediump float;\n\nuniform sampler2D texture;\n\nvarying vec2 uv;\n\nvoid main () {\n  gl_FragColor = texture2D(texture, uv);\n}\n",vert:"\nprecision mediump float;\n\nuniform mat4 modelViewProjection;\n\nattribute vec2 position;\n\nvarying vec2 uv;\n\nvoid main () {\n  uv = position;\n  gl_Position = modelViewProjection * vec4(-1.0 + 2.0 * uv.x, 1.0 - 2.0 * uv.y, 0, 1);\n}\n",attributes:{position:[0,1,0,0,1,0,0,1,1,1,1,0]},uniforms:{modelViewProjection:Tr,texture:()=>m},count:6}),ei=u.regl({vert:"\n      precision mediump float;\n      uniform mat4 modelViewProjection;\n      attribute vec2 position;\n      void main () {\n        gl_Position = modelViewProjection * vec4(position, 0, 1);\n      }",frag:"\n      precision mediump float;\n      uniform vec4 color;\n      void main () {\n        gl_FragColor = vec4(color.rgb, 0.2);\n      }",depth:{enable:!1},blend:{enable:!0,func:{srcRGB:"src alpha",srcAlpha:"one",dstRGB:"one minus src alpha",dstAlpha:"one minus src alpha"}},attributes:{position:()=>jn},uniforms:{modelViewProjection:Tr,color:()=>w},elements:()=>Array.from({length:jn.length-2},((e,t)=>[0,t+1,t+2]))}),ti=e=>{const t=new Float32Array(2*e);let n=0;for(let o=0;o<e;++o){const e=jo(o);t[n]=e[0],t[n+1]=e[1],n+=2}return t},ni=(e,t={})=>{const n=e.length;co=Math.max(2,Math.ceil(Math.sqrt(n))),uo=.5/co;const o=new Float32Array(co**2*4);let r=!0,i=!0,a=0,s=0,l=0;for(let t=0;t<n;++t)a=4*t,o[a]=e[t][0],o[a+1]=e[t][1],s=e[t][2]||0,l=e[t][3]||0,o[a+2]=s,o[a+3]=l,r&&=Number.isInteger(s),i&&=Number.isInteger(l);return xo=t.z&&X.includes(t.z)?t.z:r?K:H,bo=t.w&&X.includes(t.w)?t.w:i?K:H,u.regl.texture({data:o,shape:[co,co,4],type:"float"})},oi=(e,t={})=>{vo=!1,kn=e.length,Fn=kn,Gn&&Gn.destroy(),Gn=ni(e,t),Un({usage:"static",type:"float",data:ti(kn)}),Sn=new S(e,(e=>e[0]),(e=>e[1]),16),vo=!0},ri=(e,t)=>{eo=cn.target,to=e,no=cn.distance[0],oo=t},ii=e=>{const t="inherit"===Ot?y:Ot;if("segment"===t){const t=bt.length-1;return t<1?[]:e.reduce(((e,n,o)=>{let r=0;const i=[];for(let e=2;e<n.length;e+=2){const t=Math.sqrt((n[e-2]-n[e])**2+(n[e-1]-n[e+1])**2);i.push(t),r+=t}e[o]=[0];let a=0;for(let s=0;s<n.length/2-1;s++)a+=i[s],e[o].push(4*Math.floor(a/r*t));return e}),[])}if(t){const e=sn(t),n=mr(pr(t),"inherit"===Ot?dt:bt);return In.reduce(((t,[o,r])=>(t[o]=4*n(r[e]),t)),[])}return Array(In.length).fill(0)},ai=()=>{const e="inherit"===Bt?qt:Bt;if("segment"===e){const e=Lt.length-1;return e<1?[]:In.reduce(((t,[n,o,r])=>(t[n]=O(r,(t=>Lt[Math.floor(t/(r-1)*e)])),t)),[])}if(e){const t=sn(e),n="inherit"===Bt?Zt:Lt,o=mr(pr(e),n);return In.reduce(((e,[r,i])=>(e[r]=n[o(i[t])],e)),[])}},si=()=>{const e="inherit"===kt?Xt:kt;if("segment"===e){const e=zt.length-1;return e<1?[]:In.reduce(((t,[n,o,r])=>(t[n]=O(r,(t=>zt[Math.floor(t/(r-1)*e)])),t)),[])}if(e){const t=sn(e),n="inherit"===kt?jt:zt,o=mr(pr(e),n);return In.reduce(((e,[r,i])=>(e[r]=n[o(i[t])],e)),[])}},li=e=>new Promise((t=>{An.setPoints([]),e&&e.length?(Rn=!0,nn(e,{maxIntPointsPerSegment:Ft,tolerance:Nt}).then((e=>{(e=>{In=[];let t=0;Object.keys(e).forEach(((n,o)=>{In[n]=[o,e[n].reference,e[n].length/2,t],t+=e[n].length/2}))})(e);const n=Object.values(e);An.setPoints(1===n.length?n[0]:n,{colorIndices:ii(n),opacities:ai(),widths:si()}),Rn=!1,t()}))):t()})),ci=(e,{preventEvent:t=!1}={})=>{const o=Array.isArray(e)?e:[e];xn=!0,bn.clear();const r=[],i=[];for(let e=o.length-1;e>=0;e--){const t=o[e];t<0||t>=kn?o.splice(e,1):(bn.add(t),r.push.apply(r,jo(t)),vn.has(t)&&i.push(t))}return Un.subdata(r),Wo(i,{preventEvent:t}),bn.has(lo)||Zo(-1,{preventEvent:t}),new Promise((e=>{const r=()=>{n.subscribe("draw",(()=>{t||n.publish("filter",{points:o}),e()}),1),Zn=!0};wt||Fo(Sn.points[0])?li(Bo()).then((()=>{t||n.publish("pointConnectionsDraw"),Wo(i,{preventEvent:t}),r()})):r()}))},di=()=>$o(zn[0],zn[1],$n[0],$n[1]),ui=z((()=>{Fn=di().length}),ln),pi=()=>Boolean(Hn&&Kn),mi=()=>Boolean(void 0!==eo&&void 0!==to&&void 0!==no&&void 0!==oo),hi=(e,t)=>{mo||(mo=performance.now());const n=performance.now()-mo,o=(r=t(n/e),i=0,a=1,Math.min(a,Math.max(i,r)));var r,i,a;return pi()&&Gr({t:o}),mi()&&(e=>{const[t,n]=eo,[o,r]=to,i=1-e,a=t*i+o*e,s=n*i+r*e,l=no*i+oo*e;cn.lookAt([a,s],l)})(o),n<e},fi=()=>{po=!1,mo=null,ro=void 0,io=void 0,Ee=ho,Hn&&(Hn.destroy(),Hn=void 0),Kn&&(Kn.destroy(),Kn=void 0),eo=void 0,to=void 0,no=void 0,oo=void 0,n.publish("transitionEnd")},yi=({duration:e=500,easing:t=G})=>{po&&n.publish("transitionEnd"),po=!0,mo=null,ro=e,io=xt(t)?q[t]||G:t,ho=Ee,Ee=!1,n.publish("transitionStart")},gi=e=>(...t)=>{const n=e(...t);return Zn=!0,n},vi=(e,t={})=>new Promise((o=>{const r=[e.x+e.width/2,e.y+e.height/2],i=2*Math.atan(1),a=e.height*En>e.width?e.height/2/Math.tan(i/2):e.width/2/Math.tan(i*En/2);t.transition?(cn.config({isFixed:!0}),ri(r,a),n.subscribe("transitionEnd",(()=>{o(),cn.config({isFixed:!1})}),1),yi({duration:t.transitionDuration,easing:t.transitionEasing})):(cn.lookAt(r,a),n.subscribe("draw",o,1),Zn=!0)})),wi=(e,t,o={})=>new Promise((r=>{o.transition?(cn.config({isFixed:!0}),ri(e,t),n.subscribe("transitionEnd",(()=>{r(),cn.config({isFixed:!1})}),1),yi({duration:o.transitionDuration,easing:o.transitionEasing})):(cn.lookAt(e,t),n.subscribe("draw",r,1),Zn=!0)})),xi=()=>{An.setStyle({color:tr(bt,St,Tt),opacity:null===Lt?null:Lt[0],width:zt[0]})},bi=()=>{const e=Math.round(pn)>.5?0:255;Go.initiator.style.border=`1px dashed rgba(${e}, ${e}, ${e}, 0.33)`,Go.initiator.style.background=`rgba(${e}, ${e}, ${e}, 0.1)`},Si=()=>{const e=Math.round(pn)>.5?0:255;Go.longPressIndicator.style.color=`rgb(${e}, ${e}, ${e})`,Go.longPressIndicator.dataset.color=`rgb(${e}, ${e}, ${e})`;const t=w.map((e=>Math.round(255*e)));Go.longPressIndicator.dataset.activeColor=`rgb(${t[0]}, ${t[1]}, ${t[2]})`},Ei=e=>{e&&cn.setView(e)},Pi=(e,t)=>n=>{if("inherit"===n)e([...t()]);else{const t=Et(n)?n:[n];e(t.map((e=>Mt(e,!0))))}xi()},Ci=Pi((e=>{bt=e}),(()=>dt)),Mi=Pi((e=>{St=e}),(()=>pt)),Ai=Pi((e=>{Tt=e}),(()=>vt)),Ii=(e={})=>{var t,o,r,i,a,s,l,c,d,h,S,I,T,O,z,k,_,Z,q,G,H,K,X,Y,U,Q,ee,te,ne,oe,re,ie,ae,se,le,ce,de,pe,he;return rn(e),void 0===e.backgroundColor&&void 0===e.background||(t=e.backgroundColor||e.background)&&(p=Mt(t,!0),pn=It(p),bi(),Si()),void 0!==e.backgroundImage&&((o=e.backgroundImage)?xt(o)?gt(u.regl,o).then((e=>{m=e,Zn=!0,n.publish("backgroundImageReady")})).catch((()=>{console.error(`Count not create texture from ${o}`),m=null})):m="texture2d"===o._reglType?o:null:m=null),void 0!==e.cameraTarget&&(r=e.cameraTarget)&&cn.lookAt(r,cn.distance[0],cn.rotation),void 0!==e.cameraDistance&&(i=e.cameraDistance)>0&&cn.lookAt(cn.target,i,cn.rotation),void 0!==e.cameraRotation&&null!==(a=e.cameraRotation)&&cn.lookAt(cn.target,cn.distance[0],a),void 0!==e.cameraView&&Ei(e.cameraView),void 0!==e.colorBy&&(s=e.colorBy,y=an(s,Ne)),void 0!==e.pointColor&&ir(e.pointColor),void 0!==e.pointColorActive&&ar(e.pointColorActive),void 0!==e.pointColorHover&&sr(e.pointColorHover),void 0!==e.pointSize&&(l=e.pointSize,mt(l,ht,{minLength:1})&&(jt=[...l]),ft(+l)&&(jt=[+l]),Yn=1/jt[0],so=er(),dr()),void 0!==e.pointSizeSelected&&(!+(c=e.pointSizeSelected)||+c<0||(_t=+c)),void 0!==e.pointSizeMouseDetection&&(d=e.pointSizeMouseDetection,Vt=d,dr()),void 0!==e.sizeBy&&(e=>{Xt=an(e,Ae)})(e.sizeBy),void 0!==e.opacity&&(h=e.opacity,mt(h,ht,{minLength:1})&&(Zt=[...h]),ft(+h)&&(Zt=[+h]),so=er()),void 0!==e.showPointConnections&&(S=e.showPointConnections,wt=!!S,wt?Fo(Sn.points[0])&&li(Bo()).then((()=>{n.publish("pointConnectionsDraw"),Zn=!0})):li()),void 0!==e.pointConnectionColor&&Ci(e.pointConnectionColor),void 0!==e.pointConnectionColorActive&&Mi(e.pointConnectionColorActive),void 0!==e.pointConnectionColorHover&&Ai(e.pointConnectionColorHover),void 0!==e.pointConnectionColorBy&&(e=>{Ot=an(e,Ze,{allowSegment:!0})})(e.pointConnectionColorBy),void 0!==e.pointConnectionOpacityBy&&(e=>{Bt=an(e,Le,{allowSegment:!0})})(e.pointConnectionOpacityBy),void 0!==e.pointConnectionOpacity&&(e=>{mt(e,ht,{minLength:1})&&(Lt=[...e]),ft(+e)&&(Lt=[+e]),bt=bt.map((e=>(e[3]=Number.isNaN(+Lt[0])?e[3]:+Lt[0],e))),xi()})(e.pointConnectionOpacity),void 0!==e.pointConnectionOpacityActive&&(e=>{!Number.isNaN(+e)&&+e&&($t=+e)})(e.pointConnectionOpacityActive),void 0!==e.pointConnectionSize&&(I=e.pointConnectionSize,mt(I,ht,{minLength:1})&&(zt=[...I]),ft(+I)&&(zt=[+I]),xi()),void 0!==e.pointConnectionSizeActive&&(T=e.pointConnectionSizeActive,!Number.isNaN(+T)&&+T&&(Dt=Math.max(0,T))),void 0!==e.pointConnectionSizeBy&&(e=>{kt=an(e,Te,{allowSegment:!0})})(e.pointConnectionSizeBy),void 0!==e.pointConnectionMaxIntPointsPerSegment&&(O=e.pointConnectionMaxIntPointsPerSegment,Ft=Math.max(0,O)),void 0!==e.pointConnectionTolerance&&(z=e.pointConnectionTolerance,Nt=Math.max(0,z)),void 0!==e.opacityBy&&(e=>{qt=an(e,$e,{allowDensity:!0})})(e.opacityBy),void 0!==e.lassoColor&&(e=>{if(!e)return;w=Mt(e,!0),dn.setStyle({color:w});const t=w.map((e=>Math.round(255*e)));Go.longPressIndicator.dataset.activeColor=`rgb(${t[0]}, ${t[1]}, ${t[2]})`})(e.lassoColor),void 0!==e.lassoLineWidth&&(k=e.lassoLineWidth,Number.isNaN(+k)||+k<1||(x=+k,dn.setStyle({width:x}))),void 0!==e.lassoMinDelay&&+(_=e.lassoMinDelay)&&(b=+_,Go.set({minDelay:b})),void 0!==e.lassoMinDist&&+(Z=e.lassoMinDist)&&(E=+Z,Go.set({minDist:E})),void 0!==e.lassoClearEvent&&(q=e.lassoClearEvent,P=yt(J,P)(q)),void 0!==e.lassoInitiator&&(G=e.lassoInitiator,C=Boolean(G),Go.set({enableInitiator:C})),void 0!==e.lassoInitiatorParentElement&&(H=e.lassoInitiatorParentElement,M=H,Go.set({startInitiatorParentElement:M})),void 0!==e.lassoOnLongPress&&(K=e.lassoOnLongPress,A=Boolean(K)),void 0!==e.lassoLongPressTime&&(X=e.lassoLongPressTime,R=Number(X)),void 0!==e.lassoLongPressAfterEffectTime&&(Y=e.lassoLongPressAfterEffectTime,L=Number(Y)),void 0!==e.lassoLongPressEffectDelay&&(U=e.lassoLongPressEffectDelay,B=Number(U)),void 0!==e.lassoLongPressRevertEffectTime&&(e=>{$=Number(e)})(e.lassoLongPressRevertEffectTime),void 0!==e.keyMap&&(Q=e.keyMap,F=Object.entries(Q).reduce(((e,[t,n])=>(we.includes(t)&&me.includes(n)&&(e[t]=n),e)),{}),Vn=At(F),Vn[ue]?cn.config({isRotate:!0,mouseDownMoveModKey:Vn[ue]}):cn.config({isRotate:!1})),void 0!==e.mouseMode&&(ee=e.mouseMode,N=yt(W,j)(ee),cn.config({defaultMouseDownMoveAction:N===V?"rotate":"pan"})),void 0!==e.showReticle&&null!==(te=e.showReticle)&&(Ee=te),void 0!==e.reticleColor&&(ne=e.reticleColor)&&(ct=Mt(ne,!0),Tn.setStyle({color:ct}),On.setStyle({color:ct})),void 0!==e.pointOutlineWidth&&(!+(oe=e.pointOutlineWidth)||+oe<0||(Wt=+oe)),void 0!==e.height&&(e=>{if(e===D)return Yt=e,f.style.height="100%",void window.requestAnimationFrame((()=>{f&&cr(f.getBoundingClientRect().height)}));!+e||+e<=0||(Yt=+e,cr(Yt),f.style.height=`${Yt}px`)})(e.height),void 0!==e.width&&(e=>{if(e===D)return Ut=e,f.style.width="100%",void window.requestAnimationFrame((()=>{f&&ur(f.getBoundingClientRect().width)}));!+e||+e<=0||(Ut=+e,ur(Ut),f.style.width=`${Jt}px`)})(e.width),void 0!==e.aspectRatio&&(+(re=e.aspectRatio)<=0||(_n=re)),void 0!==e.xScale&&(ie=e.xScale)&&(Eo=ie,Co=ie.domain()[0],Mo=ie?ie.domain()[1]-ie.domain()[0]:0,Eo.range([0,Jt]),lr()),void 0!==e.yScale&&(ae=e.yScale)&&(Po=ae,Ao=Po.domain()[0],Io=Po?Po.domain()[1]-Po.domain()[0]:0,Po.range([tn,0]),lr()),void 0!==e.deselectOnDblClick&&(se=e.deselectOnDblClick,g=!!se),void 0!==e.deselectOnEscape&&(le=e.deselectOnEscape,v=!!le),void 0!==e.opacityByDensityFill&&(ce=e.opacityByDensityFill,Gt=+ce),void 0!==e.opacityInactiveMax&&(de=e.opacityInactiveMax,Ht=+de),void 0!==e.opacityInactiveScale&&(pe=e.opacityInactiveScale,Kt=+pe),void 0!==e.gamma&&(he=e.gamma,u.gamma=he),new Promise((e=>{window.requestAnimationFrame((()=>{f&&(or(),cn.refresh(),u.refresh(),Zn=!0,e())}))}))},Ri=()=>{cn||(cn=h(f,{isPanInverted:[!1,!0]})),t.cameraView?cn.setView(i(t.cameraView)):t.cameraTarget||t.cameraDistance||t.cameraRotation?cn.lookAt([...t.cameraTarget||Ke],t.cameraDistance||1,t.cameraRotation||0):cn.setView(i(Xe)),$n=Oo(1,1),zn=Oo(-1,-1)},Ti=({key:e})=>{if("Escape"===e)v&&Vo()},Oi=()=>{So=!0,wo=!0},Li=()=>{Zo(),So=!1,wo=!0,Zn=!0},Bi=()=>{Zn=!0},$i=()=>{cn.refresh();const e=Ut===D,t=Yt===D;if(e||t){const{width:n,height:o}=f.getBoundingClientRect();e&&ur(n),t&&cr(o),or(),Zn=!0}},zi=u.onFrame((()=>{go=cn.tick(),vo&&(Zn||po)&&(po&&!hi(ro,io)&&fi(),go&&($n=Oo(1,1),zn=Oo(-1,-1),"density"===qt&&ui()),u.render((()=>{((e,t)=>{Cn[0]=e/En,Cn[5]=t})(f.width/u.canvas.width,f.height/u.canvas.height),m&&m._reglType&&Qr(),jn.length>2&&ei(),po||An.draw({projection:Ar(),model:Rr(),view:Ir()}),Kr(),mn||!Ee&&!qn||(()=>{if(!(lo>=0))return;const[e,t]=Sn.points[lo].slice(0,2),n=[e,t,0,1];s(o,Cn,s(o,cn.view,Mn)),d(n,n,o),Tn.setPoints([-1,n[1],1,n[1]]),On.setPoints([n[0],1,n[0],-1]),Tn.draw(),On.draw(),Hr((()=>(_t+2*Wt)*window.devicePixelRatio),(()=>1),Qn,1)(),Hr((()=>(_t+Wt)*window.devicePixelRatio),(()=>1),Qn,3)()})(),lo>=0&&Xr(),gn.length&&(Yr(),Ur(),Jr()),dn.draw({projection:Ar(),model:Rr(),view:Ir()})}),f),go&&(lr(),Wn?Wn=!1:n.publish("view",{view:cn.view,camera:cn,xScale:Eo,yScale:Po})),Zn=!1,qn=!1,n.publish("draw"))}));return(()=>{or(),Ri(),lr(),dn=I(u.regl,{color:w,width:x,is2d:!0}),An=I(u.regl,{color:bt,colorHover:Tt,colorActive:St,opacity:null===Lt?null:Lt[0],width:zt[0],widthActive:Dt,is2d:!0}),Tn=I(u.regl,{color:ct,width:1,is2d:!0}),On=I(u.regl,{color:ct,width:1,is2d:!0}),dr(),f.addEventListener("wheel",Bi),Un=u.regl.buffer(),Jn=u.regl.buffer(),Qn=u.regl.buffer({usage:"dynamic",type:"float",length:2*k}),ao=nr(),so=er();const e=Ii({backgroundImage:m,width:Ut,height:Yt,keyMap:F});bi(),Si(),window.addEventListener("keyup",Ti,!1),window.addEventListener("blur",Qo,!1),window.addEventListener("mouseup",Xo,!1),window.addEventListener("mousemove",Jo,!1),f.addEventListener("mousedown",Ko,!1),f.addEventListener("mouseenter",Oi,!1),f.addEventListener("mouseleave",Li,!1),f.addEventListener("click",Yo,!1),f.addEventListener("dblclick",Uo,!1),"ResizeObserver"in window?(Dn=new ResizeObserver($i),Dn.observe(f)):(window.addEventListener("resize",$i),window.addEventListener("orientationchange",$i)),e.then((()=>{n.publish("init")}))})(),{get isSupported(){return u.isSupported},clear:gi((()=>{oi([]),An.clear()})),createTextureFromUrl:(e,t=15e3)=>gt(u.regl,e,t),deselect:Vo,destroy:()=>{vo=!1,un=!0,zi(),window.removeEventListener("keyup",Ti,!1),window.removeEventListener("blur",Qo,!1),window.removeEventListener("mouseup",Xo,!1),window.removeEventListener("mousemove",Jo,!1),f.removeEventListener("mousedown",Ko,!1),f.removeEventListener("mouseenter",Oi,!1),f.removeEventListener("mouseleave",Li,!1),f.removeEventListener("click",Yo,!1),f.removeEventListener("dblclick",Uo,!1),f.removeEventListener("wheel",Bi,!1),Dn?Dn.disconnect():(window.removeEventListener("resize",$i),window.removeEventListener("orientationchange",$i)),f=void 0,cn.dispose(),cn=void 0,dn.destroy(),Go.destroy(),An.destroy(),Tn.destroy(),On.destroy(),t.renderer||u.destroy(),n.publish("destroy"),n.clear()},draw:(e,t={})=>{return un?Promise.reject(new Error("The instance was already destroyed")):(o=e,new Promise(((e,t)=>{if(!o||Array.isArray(o))e(o);else{const n=Array.isArray(o.x)||ArrayBuffer.isView(o.x)?o.x.length:0,r=(Array.isArray(o.x)||ArrayBuffer.isView(o.x))&&(e=>o.x[e]),i=(Array.isArray(o.y)||ArrayBuffer.isView(o.y))&&(e=>o.y[e]),a=(Array.isArray(o.line)||ArrayBuffer.isView(o.line))&&(e=>o.line[e]),s=(Array.isArray(o.lineOrder)||ArrayBuffer.isView(o.lineOrder))&&(e=>o.lineOrder[e]),l=Object.keys(o),c=(()=>{const e=l.find((e=>at.has(e)));return e&&(Array.isArray(o[e])||ArrayBuffer.isView(o[e]))&&(t=>o[e][t])})(),d=(()=>{const e=l.find((e=>st.has(e)));return e&&(Array.isArray(o[e])||ArrayBuffer.isView(o[e]))&&(t=>o[e][t])})();r&&i&&c&&d&&a&&s?e(o.x.map(((e,t)=>[e,i(t),c(t),d(t),a(t),s(t)]))):r&&i&&c&&d&&a?e(Array.from({length:n},((e,t)=>[r(t),i(t),c(t),d(t),a(t)]))):r&&i&&c&&d?e(Array.from({length:n},((e,t)=>[r(t),i(t),c(t),d(t)]))):r&&i&&c?e(Array.from({length:n},((e,t)=>[r(t),i(t),c(t)]))):r&&i?e(Array.from({length:n},((e,t)=>[r(t),i(t)]))):t(new Error("You need to specify at least x and y"))}}))).then((e=>new Promise((o=>{if(un)return void o();let r=!1;t.preventFilterReset&&e?.length===kn||(xn=!1,bn.clear());const i=e&&Fo(e[0])&&(wt||t.showPointConnectionsOnce),{zDataType:a,wDataType:s}=t;e&&(t.transition&&(e.length===kn?r=((e,t={})=>{if(!Gn)return!1;if(po){const e=Hn;Hn=Kn,e.destroy()}else Hn=Gn;return Kn=ni(e,t),Xn=u.regl.framebuffer({color:Kn,depth:!1,stencil:!1}),Gn=void 0,!0})(e,{z:a,w:s}):console.warn("Cannot transition! The number of points between the previous and current draw call must be identical.")),oi(e,{z:a,w:s}),void 0!==t.hover&&Zo(t.hover,{preventEvent:!0}),void 0!==t.select&&Wo(t.select,{preventEvent:!0}),void 0!==t.filter&&ci(t.filter,{preventEvent:!0}),i&&li(e).then((()=>{n.publish("pointConnectionsDraw"),Zn=!0,qn=t.showReticleOnce}))),t.transition&&r?(i?Promise.all([new Promise((e=>{n.subscribe("transitionEnd",(()=>{Zn=!0,qn=t.showReticleOnce,e()}),1)})),new Promise((e=>{n.subscribe("pointConnectionsDraw",e,1)}))]).then(o):n.subscribe("transitionEnd",(()=>{Zn=!0,qn=t.showReticleOnce,o()}),1),yi({duration:t.transitionDuration,easing:t.transitionEasing})):(i?Promise.all([new Promise((e=>{n.subscribe("draw",e,1)})),new Promise((e=>{n.subscribe("pointConnectionsDraw",e,1)}))]).then(o):n.subscribe("draw",o,1),Zn=!0,qn=t.showReticleOnce)}))));var o},filter:ci,get:e=>(rn({property:!0}),"aspectRatio"===e?_n:"background"===e||"backgroundColor"===e?p:"backgroundImage"===e?m:"camera"===e?cn:"cameraTarget"===e?cn.target:"cameraDistance"===e?cn.distance[0]:"cameraRotation"===e?cn.rotation:"cameraView"===e?cn.view:"canvas"===e?f:"colorBy"===e?y:"sizeBy"===e?Xt:"deselectOnDblClick"===e?g:"deselectOnEscape"===e?v:"height"===e?Yt:"lassoColor"===e?w:"lassoLineWidth"===e?x:"lassoMinDelay"===e?b:"lassoMinDist"===e?E:"lassoClearEvent"===e?P:"lassoInitiator"===e?C:"lassoInitiatorElement"===e?Go.initiator:"lassoInitiatorParentElement"===e?M:"keyMap"===e?{...F}:"mouseMode"===e?N:"opacity"===e?1===Zt.length?Zt[0]:Zt:"opacityBy"===e?qt:"opacityByDensityFill"===e?Gt:"opacityByDensityDebounceTime"===e?ln:"opacityInactiveMax"===e?Ht:"opacityInactiveScale"===e?Kt:"points"===e?Sn.points:"hoveredPoint"===e?lo:"selectedPoints"===e?[...gn]:"filteredPoints"===e?xn?Array.from(bn):Array.from({length:Sn.points.length},((e,t)=>t)):"pointsInView"===e?di():"pointColor"===e?1===dt.length?dt[0]:dt:"pointColorActive"===e?1===pt.length?pt[0]:pt:"pointColorHover"===e?1===vt.length?vt[0]:vt:"pointOutlineWidth"===e?Wt:"pointSize"===e?1===jt.length?jt[0]:jt:"pointSizeSelected"===e?_t:"pointSizeMouseDetection"===e?Vt:"showPointConnections"===e?wt:"pointConnectionColor"===e?1===bt.length?bt[0]:bt:"pointConnectionColorActive"===e?1===St.length?St[0]:St:"pointConnectionColorHover"===e?1===Tt.length?Tt[0]:Tt:"pointConnectionColorBy"===e?Ot:"pointConnectionOpacity"===e?1===Lt.length?Lt[0]:Lt:"pointConnectionOpacityBy"===e?Bt:"pointConnectionOpacityActive"===e?$t:"pointConnectionSize"===e?1===zt.length?zt[0]:zt:"pointConnectionSizeActive"===e?Dt:"pointConnectionSizeBy"===e?kt:"pointConnectionMaxIntPointsPerSegment"===e?Ft:"pointConnectionTolerance"===e?Nt:"reticleColor"===e?ct:"regl"===e?u.regl:"showReticle"===e?Ee:"version"===e?"1.8.5":"width"===e?Ut:"xScale"===e?Eo:"yScale"===e?Po:"performanceMode"===e?on:"gamma"===e?u.gamma:"renderer"===e?u:"isDestroyed"===e?un:"isPointsDrawn"===e?vo:"isPointsFiltered"===e?xn:"zDataType"===e?xo:"wDataType"===e?bo:void 0),getScreenPosition:e=>{if(!vo)throw new Error(lt);const t=Sn.points[e];if(!t)return;const n=[t[0],t[1],0,1];s(o,Pn,s(o,cn.view,Mn)),d(n,n,o);return[Jt*(n[0]+1)/2,tn*(.5-n[1]/2)]},hover:Zo,redraw:()=>{Zn=!0},refresh:u.refresh,reset:gi((({preventEvent:e=!1}={})=>{Ri(),lr(),e||n.publish("view",{view:cn.view,camera:cn,xScale:Eo,yScale:Po})})),select:Wo,set:Ii,export:()=>f.getContext("2d").getImageData(0,0,f.width,f.height),subscribe:n.subscribe,unfilter:({preventEvent:e=!1}={})=>(xn=!1,bn.clear(),Un.subdata(ti(kn)),new Promise((t=>{const o=()=>{n.subscribe("draw",(()=>{e||n.publish("unfilter"),t()}),1),Zn=!0};wt||Fo(Sn.points[0])?li(Bo()).then((()=>{e||n.publish("pointConnectionsDraw"),o()})):o()}))),unsubscribe:n.unsubscribe,view:(e,{preventEvent:t=!1}={})=>{Ei(e),Zn=!0,Wn=t},zoomToLocation:wi,zoomToArea:vi,zoomToPoints:(e,t={})=>{if(!vo)return Promise.reject(new Error(lt));const n=(e=>{let t=1/0,n=-1/0,o=1/0,r=-1/0;for(let i=0;i<e.length;i++){const[a,s]=Sn.points[e[i]];t=Math.min(t,a),n=Math.max(n,a),o=Math.min(o,s),r=Math.max(r,s)}return{x:t,y:o,width:n-t,height:r-o}})(e),o=n.x+n.width/2,r=n.y+n.height/2,i=Lo(),a=1+(t.padding||0),s=Math.max(n.width,i)*a,l=Math.max(n.height,i)*a;return vi({x:o-s/2,y:r-l/2,width:s,height:l},t)},zoomToOrigin:(e={})=>wi([0,0],1,e)}};export{ct as checkSupport,dt as createRegl,Rt as createRenderer,gt as createTextureFromUrl,ln as default};
